#load("ostrowski/bco_valid.txt", "walnut", bco_lsd_valid(a, x))
#load("ostrowski/bco_leq.txt", "walnut", bco_leq(x, y))
#load("ostrowski/bco_adder.txt", "walnut", bco_adder(a, x, y, z))
#load("ostrowski/bco_finite_rep.txt", "walnut", bco_finite_rep(n))
#load("ostrowski/bco_standard.txt", "walnut", bco_standard(n))

Define fromBase3Pair x y :=
    match (x, y) with
    case (0, 0) => 0
    case (0, 1) => 1
    case (1, 0) => 2
    case (1, 1) => "NOT IN BASE 3"
    end.

Define fromBase3 xs ys := zipWith fromBase3Pair xs ys.

Define base3Format var reps :=
    match reps with
    case [(prefix1, cycle1), (prefix2, cycle2)] =>
        (var, concatenate (fromBase3 prefix1 prefix2) ^ "(" ^ concatenate (fromBase3 cycle1 cycle2) ^ ")^ω")
    end.

Define fromSeparatedBinary l := map fromBinary (splitOn 2 l).

Define rotateOnto l1 l2 :=
    match l2 with
    case x :: xs => (l1 @ [x], xs @ [x])
    end.

Define normalizeOstrowski prefix cycle :=
    if isEmpty prefix then
        uncurry normalizeOstrowski (rotateOnto prefix cycle)
    else if (last prefix = 2) & (last cycle = 2) then (prefix, cycle)
    else uncurry normalizeOstrowski (rotateOnto prefix cycle) .

Define bracket str := "[" ^ toString str ^ "]" .

// We want the prefix to end in 2 so everything is nice
Define ostrowskiStr prefix cycle :=
    let (newPrefix, newCycle) := normalizeOstrowski prefix cycle in
    // Take tail because all strings start with "2..." (i.e., an empty number), which we ignore because it's uninteresting (and shouldn't actually matter)
        concatenate (map bracket (tail (fromSeparatedBinary newPrefix))) ^ "(" ^ concatenate (map bracket (fromSeparatedBinary newCycle)) ^ ")^ω" .

Define ostrowskiFormat var reps :=
    match reps with
    case [(prefix1, cycle1), (prefix2, cycle2)] =>
        (var, ostrowskiStr (fromBase3 prefix1 prefix2) (fromBase3 cycle1 cycle2))
    end.

bco_valid(a, x) := bco_lsd_valid(a, x) & bco_finite_rep(x)
bco_valid2(a, x, y) := bco_valid(a, x) & bco_valid(a, y)
bco_valid3(a, x, y, z) := bco_valid2(a, x, y) & bco_valid(a, z)

bco_eq(x, y) := bco_leq(x, y) & bco_leq(y, x)
bco_lt(x, y) := bco_leq(x, y) & !bco_eq(x,y)

// bco_adder(a,x,y,z) := bco_adder_no_check(a,x,y,z) & bco_valid3(a,x,y,z)

bco_zero(z) := exists a. bco_valid(a,z) & forall y. bco_valid(a,y) => bco_leq(z,y)
bco_succ(a, x, y) := bco_valid2(a, x, y) & bco_leq(x, y) & (!bco_eq(x, y)) & forall z. bco_valid(a,z) => (bco_leq(z,x) | bco_leq(y,z))

x is ostrowski(alpha) := bco_valid(alpha, x)

#type(ostrowski(alpha), {
    "adder": bco_adder(alpha, any, any, any),
    "less": bco_leq(any, any),
    "equal": bco_eq(any, any),
    "zero": bco_zero(any)
})


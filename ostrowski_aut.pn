#import("ostrowski_defs.pn")

#load("ostrowski-automata/sturmian_word.aut", "hoa", $C(n))

// Restrict i, p, n are ostrowski(a).
// eventually_periodic(a, p) := @postprocess[p > 0 & exists n. forall i. i > n => $C[i] = $C[i + p]]
// #save_aut("automata/eventually_periodic.aut", eventually_periodic)
// #forget(p)
// #forget(n)
// #forget(i)

// pow_2(a, i, n) :=
//     @postprocess[@no_simplify[
//         bco_valid2(a, i, n) &
//         bco_positive(i) &
//         bco_positive(n) &
//         forall bound.
//         @postprocess[(@postprocess[bco_valid(a, bound) & bco_adder(a, i, n, bound)] =>
//         @postprocess[forall j. @postprocess[@postprocess[bco_lt(j, bound) & bco_leq(i, j) & bco_valid(a, j)] =>
//             @postprocess[forall jn. bco_adder(a, j, n, jn) => $C[j] = $C[jn]]]])]
//     ]]
// #save_aut("automata/pow_2.aut", pow_2)

// antisquare(a, i, n) :=
//     @postprocess[@no_simplify[
//         bco_valid2(a, i, n) &
//         bco_positive(i) &
//         bco_positive(n) &
//         forall bound.
//         @postprocess[(@postprocess[bco_valid(a, bound) & bco_adder(a, i, n, bound)] =>
//         @postprocess[forall j. @postprocess[@postprocess[bco_lt(j, bound) & bco_leq(i, j) & bco_valid(a, j)] =>
//             @postprocess[forall jn. bco_adder(a, j, n, jn) => $C[j] != $C[jn]]]])]
//     ]]
// #save_aut("automata/antisquare.aut", antisquare)

// #load("automata/pow_2.aut", "hoa", pow_2(a, i, n))

Restrict i, j, k, l, n are ostrowski(a).

// Define genNthPow num :=
//     let $PREV_POW := "pow_" ^ (toString (num - 1)) in
//     let $POW_NAME := "pow_" ^ (toString num) in
//     let fname := "automata/" ^ $POW_NAME ^ ".aut" in do
//         emit { $POW_NAME(a, i, n) := @postprocess[pow_2(a, i, n) & $PREV_POW(a, i + n, n)] };
//         emit { #save_aut(fname, $POW_NAME) }.

// Execute genNthPow 3.
// Execute genNthPow 4.
// Execute genNthPow 5.
// Execute genNthPow 6.
// Execute genNthPow 7.
// Execute genNthPow 8.

// palindrome_prefix(a, n) :=
//     @postprocess[n > 0 & forall i. (0 < i & i <= n) => $C[i] = $C[(n - i) + 1]]
// #save_aut("automata/palindrome_prefix.aut", palindrome_prefix)

// inner_reverse_complement(a,i,j,l) := @no_simplify[
//     forall t, li, lit.  @postprocess[
//         if @postprocess[bco_valid3(a,t,li,lit) & bco_leq(i, t) & bco_lt(t, j) & bco_adder(a, l, i, li) & bco_adder(a, lit, t, li)] then
//             $C[t] = $C[lit]
//     ]
// ]
// #save_aut("automata/inner_reverse_complement.aut", inner_reverse_complement)
// #load("automata/inner_reverse_complement.aut", "hoa", inner_reverse_complement(a, i, j, l))

// True when C_a[i..j] = C_a[k + 1..l + 1]^R
// where l - k = j - i
// reverse_factor(a, i, j, l) :=
//     @postprocess[
//         bco_valid3(a,i,j,l) &
//         bco_positive(i) &
//         bco_positive(l) &
//         i < j
//     ] &
//     @no_simplify[inner_reverse_complement(a, i, j, l)]
// #save_aut("automata/reverse_factor.aut", reverse_factor)
// #load("automata/reverse_factor.aut", "hoa", reverse_factor(a, i, j, l))

// not_reverse_factor(a, i, j, l) :=
//     @postprocess[
//         bco_valid3(a,i,j,l) &
//         bco_positive(i) &
//         bco_positive(l) &
//         i < j
//     ] &
//     @no_simplify[
//         exists t, li, lit. @postprocess[
//             @postprocess[@postprocess[bco_valid3(a,t,li,lit) & bco_leq(i, t) & bco_lt(t, j)] & @postprocess[bco_adder(a, l, i, li) & bco_adder(a, lit, t, li)]] & $C[t] != $C[lit]
//         ]
//     ]
// #save_aut("automata/not_reverse_factor.aut", not_reverse_factor)
// #load("automata/not_reverse_factor.aut", "hoa", not_reverse_factor(a, i, j, l))

// not_same_factor(a, i, n, j) := @no_simplify[
//     exists t. @postprocess[
//         bco_lt(t, n) &
//         exists it. @postprocess[
//             @no_simplify[bco_adder_valid(a, i, t, it)] &
//             exists jt. @postprocess[
//                 @no_simplify[bco_adder_valid(a, j, t, jt)] &
//                 $C[it] != $C[jt]
//             ]
//         ]
//     ]
// ]
// #save_aut("automata/not_same_factor.aut", not_same_factor)
// #load("automata/not_same_factor.aut", "hoa", not_same_factor(a, i, n, j))

// factor_lt(a, i, k, j) := @no_simplify[
//     @postprocess[bco_lt(i, k)] &
//     exists ji.
//         @no_simplify[bco_adder(a,ji,i,j)] &
//         @postprocess[bco_valid3(a,i,j,k)] &
//         @simplify[
//             forall t. @postprocess[
//                 if @postprocess[bco_valid(a, t) & bco_leq(i, t) & bco_lt(t, k)] then
//                     forall jit. @postprocess[
//                         if @no_simplify[bco_adder_valid(a, ji, t, jit)] then
//                             $C[t] = $C[jit]
//                     ]
//             ]
//         ]
// ]
// #save_aut("automata/factor_lt.aut", factor_lt)
// #load("automata/factor_lt.aut", "hoa", factor_lt(a, i, k, j))

// factor_lt_len(a, i, n, j) := @no_simplify[factor_lt(a, i, i + n, j)]
// #save_aut("automata/factor_lt_len.aut", factor_lt_len)
// #load("automata/factor_lt_len.aut", "hoa", factor_lt_len(a, i, n, j))

// factor_lt_test(a, i, k, j) := @no_simplify[factor_lt_small(a, i, k, j) & bco_positive(i) & bco_positive(j)]
// #save_aut("automata/factor_lt_test.aut", factor_lt_test)

// factor(a, i, n, j) :=
//     bco_valid3(a,i,n,j) &
//     forall t. @postprocess[
//         if @postprocess[bco_valid2(a, t, n) & bco_lt(t, n)] then
//             forall it. @postprocess[
//                 if @postprocess[@no_simplify[bco_adder_valid(a,i,t,it)]] then
//                     forall jt. @postprocess[
//                         if @postprocess[@no_simplify[bco_adder_valid(a,j,t,jt)]] then
//                             $C[it] = $C[jt]
//                     ]
//                 ]
//             ]
// #save_aut("automata/factor.aut", factor)
// #load("automata/factor.aut", "hoa", factor(a, i, n, j))

// True when $C_a[i..j] = \overline{C_a[k..l]}$ where $l = k + j - i$.
// anti_factor(a, i, j, k) :=
//     bco_positive(i) & bco_positive(k) &
//     @no_simplify[
//         forall t, jt, jti. @postprocess[
//             if @postprocess[bco_valid3(a,t,jt,jti) & bco_leq(i, t) & bco_lt(t, j) & bco_adder(a,j,t,jt) & bco_adder(a,jti,i,jt)] then
//                 $C[t] != $C[jti]
//         ]
//     ]
// #save_aut("automata/anti_factor.aut", anti_factor)

// reverse_anti_factor(a, i, j, l) := @no_simplify[
//     forall t, li, lit. @postprocess[
//         if @postprocess[bco_valid3(a,t,li,lit) & bco_leq(i, t) & bco_lt(t, j) & bco_adder(a, l, i, li) & bco_adder(a, lit, t, li)] then
//             $C[t] != $C[lit]
//     ]
// ]
// #save_aut("automata/reverse_anti_factor.aut", reverse_anti_factor)
// #load("automata/reverse_anti_factor.aut", "hoa", reverse_anti_factor(a, i, j, l))

// reverse_factor_len(a, i, n, l) :=
//     @postprocess[@no_simplify[reverse_factor(a, i, i + n, l)]]
// #save_aut("automata/reverse_factor_len.aut", reverse_factor_len)

// mirror_invariant_len(a,i,n) := @no_simplify[ exists t, ni. bco_adder(a, i, n, ni) & reverse_factor(a, i, ni, t) ]
// #save_aut("automata/mirror_invariant_len.aut", mirror_invariant_len)

// mirror_invariant(a,i,j) := @no_simplify[ exists t. reverse_factor(a, i, j, t) ]
// #save_aut("automata/mirror_invariant.aut", mirror_invariant)
// #load("automata/mirror_invariant.aut", "hoa", mirror_invariant(a, i, j))

// Postprocessing twice seems to help
// palindrome(a, i, n) := @postprocess[
//     bco_valid2(a, i, n) &
//     exists j, k. bco_succ(a, j, k) & k = i + n &
//     @no_simplify[forall t, ji, jit. @simplify[@postprocess[
//         if @postprocess[bco_leq(i, t) & bco_leq(t, j) & @postprocess[@no_simplify[bco_adder_valid(a, j, i, ji) & bco_adder(a, jit, t, ji)]]] then
//             $C[t] = $C[jit]
//     ]]
// ]]
// #save_aut("automata/palindrome.aut", palindrome)
// #load("automata/palindrome.aut", "hoa", palindrome(a, i, n))

// antipalindrome(a, i, n) := @postprocess[
//     bco_valid2(a, i, n) &
//     exists j, k. bco_succ(a, j, k) & k = i + n &
//     @no_simplify[forall t, ji, jit. @simplify[@postprocess[
//         if @postprocess[bco_leq(i, t) & bco_leq(t, j) & @postprocess[@no_simplify[bco_adder_valid(a, j, i, ji) & bco_adder(a, jit, t, ji)]]] then
//             $C[t] != $C[jit]
//     ]]
// ]]
// #save_aut("automata/antipalindrome.aut", antipalindrome)
// #load("automata/antipalindrome_len.aut", "hoa", antipalindrome_len(a, i, n))

// not_period(a, p, i ,j) := @postprocess[
//     !(forall t, tp.
//         if @postprocess[bco_valid2(a, t, tp) & bco_leq(i, t) & bco_leq(tp, j) & bco_adder(a,t,p,tp)] then
//             $C[t] = $C[tp])
// ]
// #save_aut("automata/not_period.aut", not_period)
// #load("automata/not_period.aut", "hoa", not_period(a, p, i, j))

// period(a, p, i, j) := @no_simplify[!not_period(a, p, i, j)]
// #save_aut("automata/period.aut", period)
// #load("automata/period.aut", "hoa", period(a, p, i, j))
// period2(a, p, i ,j) := @no_simplify[@simplify[bco_valid3(a, p, i, j)] & period(a, p, i, j)]
// #save_aut("automata/period2.aut", period2)

// least_period(a, p, i, j) := @no_simplify[
//     period(a, p, i, j) & forall p2. if @postprocess[bco_valid(a, p2) & bco_positive(p2) & bco_lt(p2, p)] then !period(a, p2, i, j)
// ]
// #save_aut("automata/least_period.aut", least_period)

// multipalindromes(a, i, j, n) := @no_simplify[ bco_positive(i) & bco_positive(j) & palindrome(a, i, n) & palindrome(a, j, n) & not_same_factor(a, i, n, j) ]
has_multipalindromes(a, n) := @no_simplify[exists s, t. multipalindromes(a,s,t,n) ]
#save_aut("automata/has_multipalindromes.aut", has_multipalindromes)


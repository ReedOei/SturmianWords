#import("ostrowski_defs.pn")

#load("ostrowski-automata/sturmian_word.aut", "hoa", $C(n))

// Restrict i, p, n are ostrowski(a).
// eventually_periodic(a, p) := @postprocess[p > 0 & exists n. forall i. i > n => $C[i] = $C[i + p]]
// #save_aut("automata/eventually_periodic.aut", eventually_periodic)
// #forget(p)
// #forget(n)
// #forget(i)

// pow_2(a, i, n) :=
//     @postprocess[@no_simplify[
//         bco_valid2(a, i, n) &
//         bco_positive(i) &
//         bco_positive(n) &
//         forall bound.
//         @postprocess[(@postprocess[bco_valid(a, bound) & bco_adder(a, i, n, bound)] =>
//         @postprocess[forall j. @postprocess[@postprocess[bco_lt(j, bound) & bco_leq(i, j) & bco_valid(a, j)] =>
//             @postprocess[forall jn. bco_adder(a, j, n, jn) => $C[j] = $C[jn]]]])]
//     ]]
// #save_aut("automata/pow_2.aut", pow_2)

// antisquare(a, i, n) :=
//     @postprocess[@no_simplify[
//         bco_valid2(a, i, n) &
//         bco_positive(i) &
//         bco_positive(n) &
//         forall bound.
//         @postprocess[(@postprocess[bco_valid(a, bound) & bco_adder(a, i, n, bound)] =>
//         @postprocess[forall j. @postprocess[@postprocess[bco_lt(j, bound) & bco_leq(i, j) & bco_valid(a, j)] =>
//             @postprocess[forall jn. bco_adder(a, j, n, jn) => $C[j] != $C[jn]]]])]
//     ]]
// #save_aut("automata/antisquare.aut", antisquare)

// #load("automata/pow_2.aut", "hoa", pow_2(a, i, n))

Restrict i, j, k, l, n are ostrowski(a).

// Define genNthPow num :=
//     let $PREV_POW := "pow_" ^ (toString (num - 1)) in
//     let $POW_NAME := "pow_" ^ (toString num) in
//     let fname := "automata/" ^ $POW_NAME ^ ".aut" in do
//         emit { $POW_NAME(a, i, n) := @postprocess[pow_2(a, i, n) & $PREV_POW(a, i + n, n)] };
//         emit { #save_aut(fname, $POW_NAME) }.

// Execute genNthPow 3.
// Execute genNthPow 4.
// Execute genNthPow 5.
// Execute genNthPow 6.
// Execute genNthPow 7.
// Execute genNthPow 8.

// palindrome_prefix(a, n) :=
//     @postprocess[n > 0 & forall i. (0 < i & i <= n) => $C[i] = $C[(n - i) + 1]]
// #save_aut("automata/palindrome_prefix.aut", palindrome_prefix)

// inner_reverse_complement(a,i,j,l) := @no_simplify[
//     forall t, li, lit.  @postprocess[
//         if @postprocess[bco_valid3(a,t,li,lit) & bco_leq(i, t) & bco_lt(t, j) & bco_adder(a, l, i, li) & bco_adder(a, lit, t, li)] then
//             $C[t] = $C[lit]
//     ]
// ]
// #save_aut("automata/inner_reverse_complement.aut", inner_reverse_complement)
// #load("automata/inner_reverse_complement.aut", "hoa", inner_reverse_complement(a, i, j, l))

// True when C_a[i..j] = C_a[k..l]^R
// where l - k = j - i
reverse_factor(a, i, j, l) := @postprocess[
    @postprocess[
        bco_positive(i) &
        bco_positive(l) &
        bco_valid3(a, i, j, l) &
        i < j
    ] &
    @no_simplify[exists li. @simplify[
        bco_adder(a, l, i, li) &
        forall t. @postprocess[
            if @postprocess[bco_leq(i, t) & bco_lt(t, j)] then
                forall lit. @postprocess[
                    if bco_adder_valid(a, lit, t, li) then
                        $C[t] = $C[lit]
                ]
            ]
        ]
    ]
]
#save_aut("automata/reverse_factor.aut", reverse_factor)
// #load("automata/reverse_factor.aut", "hoa", reverse_factor(a, i, j, l))

// not_reverse_factor(a, i, j, l) :=
//     @postprocess[
//         bco_valid3(a,i,j,l) &
//         bco_positive(i) &
//         bco_positive(l) &
//         i < j
//     ] &
//     @no_simplify[
//         exists t, li, lit. @postprocess[
//             @postprocess[@postprocess[bco_valid3(a,t,li,lit) & bco_leq(i, t) & bco_lt(t, j)] & @postprocess[bco_adder(a, l, i, li) & bco_adder(a, lit, t, li)]] & $C[t] != $C[lit]
//         ]
//     ]
// #save_aut("automata/not_reverse_factor.aut", not_reverse_factor)
// #load("automata/not_reverse_factor.aut", "hoa", not_reverse_factor(a, i, j, l))

// not_same_factor_lt(a, i, j, k) := @postprocess[
//     @postprocess[
//         bco_valid3(a,i,j,k) &
//         bco_lt(i,j)
//     ] &
//     @no_simplify[exists ki. @simplify[
//         bco_adder(a, ki, i, k) &
//         exists t. @postprocess[
//             @postprocess[bco_valid(a, t) & bco_leq(i, t) & bco_lt(t, j)] &
//             exists jit. @postprocess[
//                 bco_adder(a, ji, t, jit) & $C[t] != $C[jit]
//             ]
//         ]
//     ]]
// ]
// #save_aut("automata/not_same_factor_lt.aut", not_same_factor_lt)
// #load("automata/not_same_factor_lt.aut", "hoa", not_same_factor_lt(a, i, j, k))

// not_same_factor_len(a, i, n, j) := @no_simplify[
//     exists t. @postprocess[
//         bco_lt(t, n) &
//         exists it. @postprocess[
//             @no_simplify[bco_adder_valid(a, i, t, it)] &
//             exists jt. @postprocess[
//                 @no_simplify[bco_adder_valid(a, j, t, jt)] &
//                 $C[it] != $C[jt]
//             ]
//         ]
//     ]
// ]
// #save_aut("automata/not_same_factor_len.aut", not_same_factor_len)
// #load("automata/not_same_factor_len.aut", "hoa", not_same_factor_len(a, i, n, j))

// factor_lt(a, i, j, k) := @no_simplify[@postprocess[
//     @postprocess[bco_lt(i, j) & bco_valid3(a,i,j,k)] &
//     exists ki.
//         @no_simplify[bco_adder(a,ki,i,k)] &
//         @simplify[
//             forall t. @postprocess[
//                 if bco_leq(i, t) & bco_lt(t, j) then
//                     forall kit. @postprocess[
//                         if @no_simplify[bco_adder_valid(a, ki, t, kit)] then
//                             $C[t] = $C[kit]
//                     ]
//             ]
//         ]
// ]]
// #save_aut("automata/factor_lt.aut", factor_lt)
// #load("automata/factor_lt.aut", "hoa", factor_lt(a, i, j, k))

// factor_lt_len(a, i, n, j) := @no_simplify[@postprocess[
//     factor_lt(a, i, i + n, j)
// ]]
// #save_aut("automata/factor_lt_len.aut", factor_lt_len)
// #load("automata/factor_lt_len.aut", "hoa", factor_lt_len(a, i, n, j))

// factor(a, i, n, j) := @no_simplify[@postprocess[
//     (bco_lt(i, j) & factor_lt_len(a, i, n, j)) | (bco_lt(j, i) & factor_lt_len(a, j, n, i)) | i = j
// ]]
// #save_aut("automata/factor.aut", factor)

// factor_lt_test(a, i, k, j) := @no_simplify[factor_lt_small(a, i, k, j) & bco_positive(i) & bco_positive(j)]
// #save_aut("automata/factor_lt_test.aut", factor_lt_test)

// factor(a, i, n, j) :=
//     bco_valid3(a,i,n,j) &
//     forall t. @postprocess[
//         if @postprocess[bco_valid2(a, t, n) & bco_lt(t, n)] then
//             forall it. @postprocess[
//                 if @postprocess[@no_simplify[bco_adder_valid(a,i,t,it)]] then
//                     forall jt. @postprocess[
//                         if @postprocess[@no_simplify[bco_adder_valid(a,j,t,jt)]] then
//                             $C[it] = $C[jt]
//                     ]
//                 ]
//             ]
// #save_aut("automata/factor.aut", factor)
// #load("automata/factor.aut", "hoa", factor(a, i, n, j))

// True when $C_a[i..j] = \overline{C_a[k..l]}$ where $l = k + j - i$.
// anti_factor(a, i, j, k) :=
//     bco_positive(i) & bco_positive(k) &
//     @no_simplify[
//         forall t, jt, jti. @postprocess[
//             if @postprocess[bco_valid3(a,t,jt,jti) & bco_leq(i, t) & bco_lt(t, j) & bco_adder(a,j,t,jt) & bco_adder(a,jti,i,jt)] then
//                 $C[t] != $C[jti]
//         ]
//     ]
// #save_aut("automata/anti_factor.aut", anti_factor)

// reverse_anti_factor(a, i, j, l) := @no_simplify[
//     forall t, li, lit. @postprocess[
//         if @postprocess[bco_valid3(a,t,li,lit) & bco_leq(i, t) & bco_lt(t, j) & bco_adder(a, l, i, li) & bco_adder(a, lit, t, li)] then
//             $C[t] != $C[lit]
//     ]
// ]
// #save_aut("automata/reverse_anti_factor.aut", reverse_anti_factor)
// #load("automata/reverse_anti_factor.aut", "hoa", reverse_anti_factor(a, i, j, l))

// reverse_factor_len(a, i, n, l) :=
//     @postprocess[@no_simplify[reverse_factor(a, i, i + n, l)]]
// #save_aut("automata/reverse_factor_len.aut", reverse_factor_len)

// mirror_invariant_len(a,i,n) := @no_simplify[ exists t, ni. bco_adder(a, i, n, ni) & reverse_factor(a, i, ni, t) ]
// #save_aut("automata/mirror_invariant_len.aut", mirror_invariant_len)

// mirror_invariant(a,i,j) := @no_simplify[ exists t. reverse_factor(a, i, j, t) ]
// #save_aut("automata/mirror_invariant.aut", mirror_invariant)
// #load("automata/mirror_invariant.aut", "hoa", mirror_invariant(a, i, j))

// palindrome_idx(a, i, j) := @postprocess[
//     exists j1. @postprocess[
//         bco_succ(a, j1, j) & @no_simplify[reverse_factor(a, i, j, j1)]
//     ]
// ]
// #save_aut("automata/palindrome_idx.aut", palindrome_idx)
// #load("automata/palindrome_idx.aut", "hoa", palindrome_idx(a, i, j))

// palindrome(a, i, n) := @postprocess[
//     exists t. @postprocess[bco_adder(a, i, n, t) & palindrome(a, i, t)]
// ]
// #save_aut("automata/palindrome.aut", palindrome)
// #load("automata/palindrome.aut", "hoa", palindrome(a, i, n))

// antipalindrome(a, i, n) := @postprocess[
//     bco_valid2(a, i, n) &
//     exists j, k. bco_succ(a, j, k) & k = i + n &
//     @no_simplify[forall t, ji, jit. @simplify[@postprocess[
//         if @postprocess[bco_leq(i, t) & bco_leq(t, j) & @postprocess[@no_simplify[bco_adder_valid(a, j, i, ji) & bco_adder(a, jit, t, ji)]]] then
//             $C[t] != $C[jit]
//     ]]
// ]]
// #save_aut("automata/antipalindrome.aut", antipalindrome)
// #load("automata/antipalindrome.aut", "hoa", antipalindrome(a, i, n))

// not_period(a, p, i ,j) := @postprocess[
//     !(forall t, tp.
//         if @postprocess[bco_valid2(a, t, tp) & bco_leq(i, t) & bco_leq(tp, j) & bco_adder(a,t,p,tp)] then
//             $C[t] = $C[tp])
// ]
// #save_aut("automata/not_period.aut", not_period)
// #load("automata/not_period.aut", "hoa", not_period(a, p, i, j))

// period(a, p, i, j) := @no_simplify[!not_period(a, p, i, j)]
// #save_aut("automata/period.aut", period)
// #load("automata/period.aut", "hoa", period(a, p, i, j))
// period2(a, p, i ,j) := @no_simplify[@simplify[bco_valid3(a, p, i, j)] & period(a, p, i, j)]
// #save_aut("automata/period2.aut", period2)

// least_period(a, p, i, j) := @no_simplify[
//     period(a, p, i, j) & forall p2. if @postprocess[bco_valid(a, p2) & bco_positive(p2) & bco_lt(p2, p)] then !period(a, p2, i, j)
// ]
// #save_aut("automata/least_period.aut", least_period)

// multipalindromes(a, i, j, n) := @no_simplify[ palindrome(a, i, n) & palindrome(a, j, n) & not_same_factor(a, i, n, j) ]
// #save_aut("automata/multipalindromes.aut", multipalindromes)
// #load("automata/multipalindromes.aut", "hoa", multipalindromes(a, i, j, n))
// has_multipalindromes(a, n) := @no_simplify[exists s, t. multipalindromes(a,s,t,n) ]
// #save_aut("automata/has_multipalindromes.aut", has_multipalindromes)

// #load("automata/palindrome.aut", "hoa", palindrome(a, i, n))

// #load("automata/factor_lt.aut", "hoa", factor_lt(a, i, j, k))
// #load("automata/factor_lt_len.aut", "hoa", factor_lt_len(a, i, n, j))
// #load("automata/not_same_factor_len.aut", "hoa", not_same_factor_len(a, i, n, j))

// first_palindrome(a, i, n) := @postprocess[
//     palindrome(a, i, n) &
//     @postprocess[
//         bco_valid2(a,i,n) &
//         forall t. @postprocess[
//             if palindrome(a, t, n) & @no_simplify[factor_lt_len(a, t, n, i)] then
//                 bco_leq(i, t)
//         ]
//     ]
// ]
// #save_aut("automata/first_palindrome.aut", first_palindrome)
// #load("automata/first_palindrome.aut", "hoa", first_palindrome(a, i, n))


#import("ostrowski_defs.pn")

#load("ostrowski/sturmian_word.txt", "pecan", $C(n))

bco_positive(x) := @simplify[exists z. bco_zero(z) & bco_lt(z, x)]

// Restrict i, p, n are ostrowski(a).
// eventually_periodic(a, p) := p > 0 & exists n. forall i. i > n => $C[i] = $C[i + p]
// #save_aut("automata/eventually_periodic.aut", eventually_periodic)
// #forget(p)
// #forget(n)
// #forget(i)

// pow_2(a, i, n) :=
//     @no_simplify[
//         bco_valid2(a, i, n) &
//         bco_positive(i) &
//         forall bound.
//         @postprocess[(@postprocess[bco_valid(a, bound) & bco_adder(a, i, n, bound)] =>
//         @postprocess[forall j. @postprocess[@postprocess[bco_lt(j, bound) & bco_leq(i, j) & bco_valid(a, j)] =>
//             @postprocess[forall jn. bco_adder(a, j, n, jn) => $C[j] = $C[jn]]]])]
//     ]
// #save_aut("automata/square.aut", square)

// antisquare(a, i, n) :=
//     @no_simplify[
//         bco_valid2(a, i, n) &
//         bco_positive(i) &
//         forall bound.
//         @postprocess[(@postprocess[bco_valid(a, bound) & bco_adder(a, i, n, bound)] =>
//         @postprocess[forall j. @postprocess[@postprocess[bco_lt(j, bound) & bco_leq(i, j) & bco_valid(a, j)] =>
//             @postprocess[forall jn. bco_adder(a, j, n, jn) => $C[j] != $C[jn]]]])]
//     ]
// #save_aut("automata/antisquare.aut", antisquare)

pow_2(a, i, n) := square(a, i, n)

Restrict i, n are ostrowski(a).

Define nthPow num :=
    let $PREV_POW := "pow_" ^ (toString (num - 1)) in
    let $POW_NAME := "pow_" ^ (toString num) in
    let fname := "automata/" ^ $POW_NAME in do
        emit { $POW_NAME(a, i, n) := square(a, i, n) & $PREV_POW(a, i + n, n) };
        emit { #save_aut(fname, $POW_NAME) }.

Execute genNthPow 3.
Execute genNthPow 4.
Execute genNthPow 5.
Execute genNthPow 6.

palindrome_prefix(a, n) :=
    bco_positive(n) & forall i. (0 < i & i <= n & bco_succ(a, n1, n)) => $C[i] = $C[(n - 1) + i]
#save_aut("automata/palindrome_prefix.aut", palindrome_prefix)


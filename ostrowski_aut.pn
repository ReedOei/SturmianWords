#import("ostrowski_defs.pn")

#load("ostrowski-automata/sturmian_word.txt", "pecan", $C(n))

// Restrict i, p, n are ostrowski(a).
// eventually_periodic(a, p) := @postprocess[p > 0 & exists n. forall i. i > n => $C[i] = $C[i + p]]
// #save_aut("automata/eventually_periodic.aut", eventually_periodic)
// #forget(p)
// #forget(n)
// #forget(i)

// pow_2(a, i, n) :=
//     @postprocess[@no_simplify[
//         bco_valid2(a, i, n) &
//         bco_positive(i) &
//         bco_positive(n) &
//         forall bound.
//         @postprocess[(@postprocess[bco_valid(a, bound) & bco_adder(a, i, n, bound)] =>
//         @postprocess[forall j. @postprocess[@postprocess[bco_lt(j, bound) & bco_leq(i, j) & bco_valid(a, j)] =>
//             @postprocess[forall jn. bco_adder(a, j, n, jn) => $C[j] = $C[jn]]]])]
//     ]]
// #save_aut("automata/pow_2.aut", pow_2)

// antisquare(a, i, n) :=
//     @postprocess[@no_simplify[
//         bco_valid2(a, i, n) &
//         bco_positive(i) &
//         bco_positive(n) &
//         forall bound.
//         @postprocess[(@postprocess[bco_valid(a, bound) & bco_adder(a, i, n, bound)] =>
//         @postprocess[forall j. @postprocess[@postprocess[bco_lt(j, bound) & bco_leq(i, j) & bco_valid(a, j)] =>
//             @postprocess[forall jn. bco_adder(a, j, n, jn) => $C[j] != $C[jn]]]])]
//     ]]
// #save_aut("automata/antisquare.aut", antisquare)

// #load("automata/pow_2.aut", "hoa", pow_2(a, i, n))

Restrict i, j, k, l, n are ostrowski(a).

// Define genNthPow num :=
//     let $PREV_POW := "pow_" ^ (toString (num - 1)) in
//     let $POW_NAME := "pow_" ^ (toString num) in
//     let fname := "automata/" ^ $POW_NAME ^ ".aut" in do
//         emit { $POW_NAME(a, i, n) := @postprocess[pow_2(a, i, n) & $PREV_POW(a, i + n, n)] };
//         emit { #save_aut(fname, $POW_NAME) }.

// Execute genNthPow 3.
// Execute genNthPow 4.
// Execute genNthPow 5.
// Execute genNthPow 6.
// Execute genNthPow 7.
// Execute genNthPow 8.

// palindrome_prefix(a, n) :=
//     @postprocess[n > 0 & forall i. (0 < i & i <= n) => $C[i] = $C[(n - i) + 1]]
// #save_aut("automata/palindrome_prefix.aut", palindrome_prefix)

// inner_reverse_complement(a,i,j,l) := @no_simplify[
//     forall t, li, lit.  @postprocess[
//         if @postprocess[bco_valid3(a,t,li,lit) & bco_leq(i, t) & bco_lt(t, j) & bco_adder(a, l, i, li) & bco_adder(a, lit, t, li)] then
//             $C[t] = $C[lit]
//     ]
// ]
// #save_aut("automata/inner_reverse_complement.aut", inner_reverse_complement)
// #load("automata/inner_reverse_complement.aut", "hoa", inner_reverse_complement(a, i, j, l))

// True when C_a[i..j] = C_a[k..l]^R
// where l - k = j - i
// reverse_factor(a, i, j, l) :=
//     @postprocess[
//         bco_valid3(a,i,j,l) &
//         bco_positive(i) &
//         bco_positive(l) &
//         i < j
//     ] &
//     @no_simplify[inner_reverse_complement(a, i, j, l)]
// #save_aut("automata/reverse_factor.aut", reverse_factor)
#load("automata/reverse_factor.aut", "hoa", reverse_factor(a, i, j, l))

// not_reverse_factor(a, i, j, l) :=
//     @postprocess[
//         bco_valid3(a,i,j,l) &
//         bco_positive(i) &
//         bco_positive(l) &
//         i < j
//     ] &
//     @no_simplify[
//         exists t, li, lit. @postprocess[
//             @postprocess[@postprocess[bco_valid3(a,t,li,lit) & bco_leq(i, t) & bco_lt(t, j)] & @postprocess[bco_adder(a, l, i, li) & bco_adder(a, lit, t, li)]] & $C[t] != $C[lit]
//         ]
//     ]
// #save_aut("automata/not_reverse_factor.aut", not_reverse_factor)
// #load("automata/not_reverse_factor.aut", "hoa", not_reverse_factor(a, i, j, l))

// factor(a, i, n, j) :=
//     bco_valid3(a,i,n,j) &
//     @no_simplify[forall t, it, jt. @simplify[@postprocess[
//         if @postprocess[@postprocess[bco_valid3(a,t,it,jt) & @postprocess[bco_valid3(a,i,n,j) & bco_lt(t, n)]] & @postprocess[bco_adder(a,i,t,it) & bco_adder(a,j,t,jt)]] then
//             $C[it] = $C[jt]
//     ]]]
// #save_aut("automata/factor.aut", factor)
// #load("automata/factor.aut", "hoa", factor(a, i, n, j))

// True when $C_a[i..j] = \overline{C_a[k..l]}$ where $l = k + j - i$.
// anti_factor(a, i, j, k) :=
//     bco_positive(i) & bco_positive(k) &
//     @no_simplify[
//         forall t, jt, jti. @postprocess[
//             if @postprocess[bco_valid3(a,t,jt,jti) & bco_leq(i, t) & bco_lt(t, j) & bco_adder(a,j,t,jt) & bco_adder(a,jti,i,jt)] then
//                 $C[t] != $C[jti]
//         ]
//     ]
// #save_aut("automata/anti_factor.aut", anti_factor)

// reverse_anti_factor(a, i, j, l) := @no_simplify[
//     forall t, li, lit. @postprocess[
//         if @postprocess[bco_valid3(a,t,li,lit) & bco_leq(i, t) & bco_lt(t, j) & bco_adder(a, l, i, li) & bco_adder(a, lit, t, li)] then
//             $C[t] != $C[lit]
//     ]
// ]
// #save_aut("automata/reverse_anti_factor.aut", reverse_anti_factor)
// #load("automata/reverse_anti_factor.aut", "hoa", reverse_anti_factor(a, i, j, l))

// reverse_factor_len(a, i, n, l) :=
//     @postprocess[@no_simplify[reverse_factor(a, i, i + n, l)]]
// #save_aut("automata/reverse_factor_len.aut", reverse_factor_len)

// mirror_invariant_len(a,i,n) := @no_simplify[ exists t, ni. bco_adder(a, i, n, ni) & reverse_factor(a, i, ni, t) ]
// #save_aut("automata/mirror_invariant_len.aut", mirror_invariant_len)

// mirror_invariant(a,i,j) := @no_simplify[ exists t. reverse_factor(a, i, j, t) ]
// #save_aut("automata/mirror_invariant.aut", mirror_invariant)
// #load("automata/mirror_invariant.aut", "hoa", mirror_invariant(a, i, j))

// palindrome(a, i, j) := @postprocess[@no_simplify[reverse_factor(a, i, i + n, i + n)]]
// #save_aut("automata/palindrome.aut", palindrome)
// #load("automata/palindrome.aut", "hoa", palindrome(a, i, n))

// antipalindrome(a, i, n) := @postprocess[
//     bco_valid2(a, i, n) &
//     exists j. j = i + n &
//     @no_simplify[forall t, ji, jit. @simplify[@postprocess[
//         if @postprocess[bco_valid3(a,t,ji,jit) & bco_valid2(a, i, j) & bco_leq(i, t) & bco_lt(t, j) & @postprocess[bco_adder(a, j, i, ji) & bco_adder(a, jit, t, ji)]] then
//             $C[t] != $C[jit]
//     ]]
// ]]
// #save_aut("automata/antipalindrome_len.aut", antipalindrome)
// #load("automata/antipalindrome_len.aut", "hoa", antipalindrome_len(a, i, n))

// not_period(a, p, i ,j) := @postprocess[
//     !(forall t, tp.
//         if @postprocess[bco_valid2(a, t, tp) & bco_leq(i, t) & bco_leq(tp, j) & bco_adder(a,t,p,tp)] then
//             $C[t] = $C[tp])
// ]
// #save_aut("automata/not_period.aut", not_period)
// #load("automata/not_period.aut", "hoa", not_period(a, p, i, j))

// period(a, p, i, j) := @no_simplify[!not_period(a, p, i, j)]
// #save_aut("automata/period.aut", period)
// #load("automata/period.aut", "hoa", period(a, p, i, j))

// least_period(a, p, i, j) := @no_simplify[
//     period(a, p, i, j) & forall p2. if @postprocess[bco_valid(a, p2) & bco_positive(p2) & bco_lt(p2, p)] then !period(a, p2, i, j)
// ]
// #save_aut("automata/least_period.aut", least_period)


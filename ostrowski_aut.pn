#import("ostrowski_defs.pn")

#load("ostrowski-automata/sturmian_word.aut", "hoa", $C(n))

// Restrict i, p, n are ostrowski(a).
// eventually_periodic(a, p) := @postprocess[p > 0 & exists n. forall i. i > n => $C[i] = $C[i + p]]
// #save_aut("automata/eventually_periodic.aut", eventually_periodic)
// #forget(p)
// #forget(n)
// #forget(i)

// pow_2(a, i, n) :=
//     @postprocess[@no_simplify[
//         bco_valid2(a, i, n) &
//         bco_positive(i) &
//         bco_positive(n) &
//         forall bound.
//         @postprocess[(@postprocess[bco_valid(a, bound) & bco_adder(a, i, n, bound)] =>
//         @postprocess[forall j. @postprocess[@postprocess[bco_lt(j, bound) & bco_leq(i, j) & bco_valid(a, j)] =>
//             @postprocess[forall jn. bco_adder(a, j, n, jn) => $C[j] = $C[jn]]]])]
//     ]]
// #save_aut("automata/pow_2.aut", pow_2)

// antisquare(a, i, n) :=
//     @postprocess[@no_simplify[
//         bco_valid2(a, i, n) &
//         bco_positive(i) &
//         bco_positive(n) &
//         forall bound.
//         @postprocess[(@postprocess[bco_valid(a, bound) & bco_adder(a, i, n, bound)] =>
//         @postprocess[forall j. @postprocess[@postprocess[bco_lt(j, bound) & bco_leq(i, j) & bco_valid(a, j)] =>
//             @postprocess[forall jn. bco_adder(a, j, n, jn) => $C[j] != $C[jn]]]])]
//     ]]
// #save_aut("automata/antisquare.aut", antisquare)

// #load("automata/pow_2.aut", "hoa", pow_2(a, i, n))

Restrict i, j, k, l, p, n are ostrowski(a).

// Define genNthPow num :=
//     let $PREV_POW := "pow_" ^ (toString (num - 1)) in
//     let $POW_NAME := "pow_" ^ (toString num) in
//     let fname := "automata/" ^ $POW_NAME ^ ".aut" in do
//         emit { $POW_NAME(a, i, n) := @postprocess[pow_2(a, i, n) & $PREV_POW(a, i + n, n)] };
//         emit { #save_aut(fname, $POW_NAME) }.

// Execute genNthPow 3.
// Execute genNthPow 4.
// Execute genNthPow 5.
// Execute genNthPow 6.
// Execute genNthPow 7.
// Execute genNthPow 8.

// factor_lt(a, i, j, k) := @no_simplify[@postprocess[
//     @postprocess[bco_positive(i) & bco_lt(i, j) & bco_valid3(a,i,j,k)] &
//     exists ki.
//         @no_simplify[bco_adder(a,ki,i,k)] &
//         @simplify[
//             forall t. @postprocess[
//                 if bco_leq(i, t) & bco_lt(t, j) then
//                     forall kit. @postprocess[
//                         if @no_simplify[bco_adder_valid(a, ki, t, kit)] then
//                             $C[t] = $C[kit]
//                     ]
//             ]
//         ]
// ]]
// #save_aut("automata/factor_lt.aut", factor_lt)
// #load("automata/factor_lt.aut", "hoa", factor_lt(a, i, j, k))

// factor_lt_len(a, i, n, j) := @no_simplify[@postprocess[
//     factor_lt(a, i, i + n, j)
// ]]
// #save_aut("automata/factor_lt_len.aut", factor_lt_len)
// #load("automata/factor_lt_len.aut", "hoa", factor_lt_len(a, i, n, j))

// True when $C_a[i..j] = \overline{C_a[k..l]}$ where $l = k + j - i$.
// anti_factor(a, i, j, k) :=
//     bco_positive(i) & bco_positive(k) &
//     @no_simplify[
//         forall t, jt, jti. @postprocess[
//             if @postprocess[bco_valid3(a,t,jt,jti) & bco_leq(i, t) & bco_lt(t, j) & bco_adder(a,j,t,jt) & bco_adder(a,jti,i,jt)] then
//                 $C[t] != $C[jti]
//         ]
//     ]
// #save_aut("automata/anti_factor.aut", anti_factor)

// reverse_anti_factor(a, i, j, l) := @no_simplify[
//     forall t, li, lit. @postprocess[
//         if @postprocess[bco_valid3(a,t,li,lit) & bco_leq(i, t) & bco_lt(t, j) & bco_adder(a, l, i, li) & bco_adder(a, lit, t, li)] then
//             $C[t] != $C[lit]
//     ]
// ]
// #save_aut("automata/reverse_anti_factor.aut", reverse_anti_factor)
// #load("automata/reverse_anti_factor.aut", "hoa", reverse_anti_factor(a, i, j, l))

// True when C_a[i..j] = C_a[k + 1..l + 1]^R
// where l - k = j - i
// reverse_factor(a, i, j, l) := @postprocess[
//     @postprocess[
//         bco_positive(i) &
//         // bco_positive(l) &
//         bco_valid3(a, i, j, l) &
//         i < j
//     ] &
//     @no_simplify[exists li. @simplify[
//         @postprocess[
//             bco_adder_valid(a, l, i, li) &
//             bco_leq(j, li)
//         ] &
//         forall t. @postprocess[
//             if @postprocess[bco_leq(i, t) & bco_lt(t, j)] then
//                 forall lit. @postprocess[
//                     if bco_adder_valid(a, lit, t, li) then
//                         $C[t] = $C[lit]
//                 ]
//             ]
//         ]
//     ]
// ]
// #save_aut("automata/reverse_factor.aut", reverse_factor)
// #load("automata/reverse_factor.aut", "hoa", reverse_factor(a, i, j, l))

// #load("automata/reverse_factor.aut", "hoa", reverse_factor(a, i, j, l))
// reverse_factor_len(a, i, n, l) :=
//     @postprocess[reverse_factor(a, i, i + n, l)]
// #save_aut("automata/reverse_factor_len.aut", reverse_factor_len)
// #load("automata/reverse_factor_len.aut", "hoa", reverse_factor_len(a, i, n, l))

// #load("automata/reverse_factor.aut", "hoa", reverse_factor(a, i, j, l))
// first_reverse_factor(a,i,j,l) := @postprocess[
//     reverse_factor(a,i,j,l) & forall k. if reverse_factor(a,i,j,k) then l <= k
// ]
// #save_aut("automata/first_reverse_factor.aut", first_reverse_factor)
// #load("automata/first_reverse_factor.aut", "hoa", first_reverse_factor(a,i,j,l))

// first_reverse_factor_len(a,i,n,l) := @postprocess[
//     first_reverse_factor(a,i,i+n,l)
// ]
// #save_aut("automata/first_reverse_factor_len.aut", first_reverse_factor_len)
// #load("automata/first_reverse_factor_len.aut", "hoa", first_reverse_factor_len(a,i,n,l))

// For some reason, this produces the smallest factor automata of the things I've tried so far...
// factor(a,i,n,j) := @postprocess[
//     bco_valid3(a,i,n,j) &
//     forall l. first_reverse_factor_len(a, i, n, l) <=> first_reverse_factor_len(a, j, n, l)
// ]
// #save_aut("automata/factor.aut", factor)

// mirror_invariant(a,i,j) := exists t. @no_simplify[reverse_factor(a, i, j, t)]
// #save_aut("automata/mirror_invariant.aut", mirror_invariant)
// #load("automata/mirror_invariant.aut", "hoa", mirror_invariant(a, i, j))

// palindrome_idx(a, i, j) := @postprocess[
//     exists j1. @postprocess[
//         bco_succ(a, j1, j) & @no_simplify[reverse_factor(a, i, j, j1)]
//     ]
// ]
// #save_aut("automata/palindrome_idx.aut", palindrome_idx)
// #load("automata/palindrome_idx.aut", "hoa", palindrome_idx(a, i, j))

// palindrome(a, i, n) := @postprocess[
//     exists t. @postprocess[bco_adder(a, i, n, t) & palindrome(a, i, t)]
// ]
// #save_aut("automata/palindrome.aut", palindrome)
// #load("automata/palindrome.aut", "hoa", palindrome(a, i, n))

// antipalindrome(a, i, n) := @postprocess[
//     bco_valid2(a, i, n) &
//     exists j, k. bco_succ(a, j, k) & k = i + n &
//     @no_simplify[forall t, ji, jit. @simplify[@postprocess[
//         if @postprocess[bco_leq(i, t) & bco_leq(t, j) & @postprocess[@no_simplify[bco_adder_valid(a, j, i, ji) & bco_adder(a, jit, t, ji)]]] then
//             $C[t] != $C[jit]
//     ]]
// ]]
// #save_aut("automata/antipalindrome.aut", antipalindrome)
// #load("automata/antipalindrome.aut", "hoa", antipalindrome(a, i, n))

////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
// TODO: Break this up into a bunch of files, one for each section of the paper?
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////

// #load("automata/factor_lt.aut", "hoa", factor_lt(a, i, j, k))
// recurrent(a,i,j) := @postprocess[
//     bco_valid2(a,i,j) &
//     forall s. @postprocess[
//         if bco_valid3(a,s,i,j) then
//             exists t. @postprocess[
//                 bco_valid(a,t) & bco_lt(s,t) & factor_lt(a,i,j,t)
//             ]
//     ]
// ]
// #save_aut("automata/recurrent.aut", recurrent)

#load("automata/factor_lt.aut", "hoa", factor_lt(a, i, j, k))
#load("automata/factor_lt_len.aut", "hoa", factor_lt_len(a, i, n, j))
uniform_recurrent(a,i,n) := @postprocess[
    exists p.
    forall k. @postprocess[
        if k > 0 then
            exists l. @postprocess[
                k <= l &
                exists kp. @postprocess[
                    bco_adder_valid(a,k,p,kp) &
                    exists kpn. @postprocess[
                        @postprocess[
                            bco_adder_valid(a,kpn,n,kp) &
                            bco_leq(l, kpn)
                        ] &
                        factor_lt_len(a,i,n,l)
                    ]
                ]
            ]
    ]
]
#save_aut("automata/uniform_recurrent.aut", uniform_recurrent)

// #load("automata/factor_lt.aut", "hoa", factor_lt(a, i, j, k))
// period(a, p, i, j) := @postprocess[
//     p > 0 &
//     exists ip, jp. @postprocess[
//         @postprocess[
//             bco_adder_valid(a,i,p,ip) & bco_adder_valid(a,jp,p,j)
//         ] &
//         factor_lt(a,i,jp,ip)
//     ]
// ]
// #save_aut("automata/period.aut", period)
// #load("automata/period.aut", "hoa", period(a, p, i, j))

// least_period(a, p, i, j) := @postprocess[
//     period(a, p, i, j) &
//     forall p2 is ostrowski(a). if period(a,p2,i,j) then bco_leq(p2, p)
// ]
// #save_aut("automata/least_period.aut", least_period)
// #load("automata/least_period.aut", "hoa", least_period(a,p,i,j))

// least_period_occurs(a,p) := @postprocess[exists i,j. i > 0 & j > 0 & least_period(a,p,i,j)]
// #save_aut("automata/least_period_occurs.aut", least_period_occurs)
// #load("automata/least_period_occurs.aut", "hoa", least_period(a,p))

// #load("automata/palindrome.aut", "hoa", palindrome(a, i, n))
// #load("automata/factor_lt_len.aut", "hoa", factor_lt_len(a, i, n, j))
// first_palindrome(a, i, n) := @postprocess[
//     palindrome(a, i, n) &
//     forall t. @postprocess[
//         if bco_positive(t) & @no_simplify[factor_lt_len(a, t, n, i)] then
//             bco_leq(i, t)
//     ]
// ]
// #save_aut("automata/first_palindrome.aut", first_palindrome)
// #load("automata/first_palindrome.aut", "hoa", first_palindrome(a, i, n))

// #load("automata/factor_lt_len.aut", "hoa", factor_lt_len(a, i, n, j))
// factor_len(a,i,n,j) :=
//     factor_lt_len(a,i,n,j) | factor_lt_len(a,j,n,i)
// #save_aut("automata/factor_len.aut", factor_len)
// #load("automata/factor_len.aut", "hoa", factor_len(a, i, n, j))

// special_factor(a,i,n) := @postprocess[
//     (exists j. @no_simplify[factor_lt_len(a,i,n,j)] & $C[j+n] = 0) &
//     (exists k. @no_simplify[factor_lt_len(a,i,n,k)] & $C[k+n] = 1)
// ]
// #save_aut("automata/special_factor.aut", special_factor)
// #load("automata/special_factor.aut", "hoa", special_factor(a,i,n))
// #load("automata/factor_lt_len.aut", "hoa", factor_lt_len(a, i, n, j))
// first_special_factor(a,i,n) := @postprocess[@postprocess[@postprocess[
//     @no_simplify[special_factor(a,i,n)] &
//     forall j. if @no_simplify[factor_lt_len(a,j,n,i)] then i <= j
// ]]]
// #save_aut("automata/first_special_factor.aut", first_special_factor)
// #load("automata/first_special_factor.aut", "hoa", first_special_factor)


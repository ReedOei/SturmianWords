#import("ostrowski_defs.pn")

#load("ostrowski-automata/sturmian_word.aut", "hoa", $C(n))

Restrict i, p, n are ostrowski(a).
eventually_periodic(a, p) := @postprocess[p > 0 & exists n. forall i. i > n => $C[i] = $C[i + p]]
#save_aut("automata/eventually_periodic.aut", eventually_periodic)
#forget(p)
#forget(n)
#forget(i)

pow_2(a, i, n) :=
    @postprocess[@no_simplify[
        bco_valid2(a, i, n) &
        bco_positive(i) &
        bco_positive(n) &
        forall bound.
        @postprocess[(@postprocess[bco_valid(a, bound) & bco_adder(a, i, n, bound)] =>
        @postprocess[forall j. @postprocess[@postprocess[bco_lt(j, bound) & bco_leq(i, j) & bco_valid(a, j)] =>
            @postprocess[forall jn. bco_adder(a, j, n, jn) => $C[j] = $C[jn]]]])]
    ]]
#save_aut("automata/pow_2.aut", pow_2)

antisquare(a, i, n) :=
    @postprocess[@no_simplify[
        bco_valid2(a, i, n) &
        bco_positive(i) &
        bco_positive(n) &
        forall bound.
        @postprocess[(@postprocess[bco_valid(a, bound) & bco_adder(a, i, n, bound)] =>
        @postprocess[forall j. @postprocess[@postprocess[bco_lt(j, bound) & bco_leq(i, j) & bco_valid(a, j)] =>
            @postprocess[forall jn. bco_adder(a, j, n, jn) => $C[j] != $C[jn]]]])]
    ]]
#save_aut("automata/antisquare.aut", antisquare)
#load("automata/antisquare.aut", "hoa", antisquare(a, i, n))

#load("automata/pow_2.aut", "hoa", pow_2(a, i, n))

Restrict i, j, k, l, p, n are ostrowski(a).
Define genNthPow num :=
    let $PREV_POW := "pow_" ^ (toString (num - 1)) in
    let $POW_NAME := "pow_" ^ (toString num) in
    let fname := "automata/" ^ $POW_NAME ^ ".aut" in do
        emit { $POW_NAME(a, i, n) := @postprocess[pow_2(a, i, n) & $PREV_POW(a, i + n, n)] };
        emit { #save_aut(fname, $POW_NAME) }.

Execute genNthPow 3.
Execute genNthPow 4.
Execute genNthPow 5.
Execute genNthPow 6.
Execute genNthPow 7.
Execute genNthPow 8.

factor_lt(a, i, j, k) := @no_simplify[@postprocess[
    @postprocess[bco_positive(i) & bco_leq(i, j) & bco_valid3(a,i,j,k)] &
    exists ki.
        @no_simplify[bco_adder(a,ki,i,k)] &
        @simplify[
            forall t. @postprocess[
                if bco_leq(i, t) & bco_lt(t, j) then
                    forall kit. @postprocess[
                        if @no_simplify[bco_adder_valid(a, ki, t, kit)] then
                            $C[t] = $C[kit]
                    ]
            ]
        ]
]]
#save_aut("automata/factor_lt.aut", factor_lt)
#load("automata/factor_lt.aut", "hoa", factor_lt(a, i, j, k))

factor_lt_len(a, i, n, j) := @no_simplify[@postprocess[
    factor_lt(a, i, i + n, j)
]]
#save_aut("automata/factor_lt_len.aut", factor_lt_len)
#load("automata/factor_lt_len.aut", "hoa", factor_lt_len(a, i, n, j))

// True when C_a[i..j] = C_a[k + 1..l + 1]^R
// where l - k = j - i
reverse_factor(a, i, j, l) := @postprocess[
    @postprocess[
        bco_positive(i) &
        // bco_positive(l) &
        bco_valid3(a, i, j, l) &
        i < j
    ] &
    @no_simplify[exists li. @simplify[
        @postprocess[
            bco_adder_valid(a, l, i, li) &
            bco_leq(j, li)
        ] &
        forall t. @postprocess[
            if @postprocess[bco_leq(i, t) & bco_lt(t, j)] then
                forall lit. @postprocess[
                    if bco_adder_valid(a, lit, t, li) then
                        $C[t] = $C[lit]
                ]
            ]
        ]
    ]
]
#save_aut("automata/reverse_factor.aut", reverse_factor)
#load("automata/reverse_factor.aut", "hoa", reverse_factor(a, i, j, l))

mirror_invariant(a,i,j) := exists t. @no_simplify[reverse_factor(a, i, j, t)]
#save_aut("automata/mirror_invariant.aut", mirror_invariant)
#load("automata/mirror_invariant.aut", "hoa", mirror_invariant(a, i, j))

palindrome_idx(a, i, j) := @postprocess[
    exists j1. @postprocess[
        bco_succ(a, j1, j) & @no_simplify[reverse_factor(a, i, j, j1)]
    ]
]
#save_aut("automata/palindrome_idx.aut", palindrome_idx)
#load("automata/palindrome_idx.aut", "hoa", palindrome_idx(a, i, j))

palindrome(a, i, n) := @postprocess[
    exists t. @postprocess[bco_adder(a, i, n, t) & palindrome_idx(a, i, t)]
]
#save_aut("automata/palindrome.aut", palindrome)
#load("automata/palindrome.aut", "hoa", palindrome(a, i, n))

antipalindrome(a, i, n) := @postprocess[
    bco_valid2(a, i, n) &
    exists j, k. bco_succ(a, j, k) & k = i + n &
    @no_simplify[forall t, ji, jit. @simplify[@postprocess[
        if @postprocess[bco_leq(i, t) & bco_leq(t, j) & @postprocess[@no_simplify[bco_adder_valid(a, j, i, ji) & bco_adder(a, jit, t, ji)]]] then
            $C[t] != $C[jit]
    ]]
]]
#save_aut("automata/antipalindrome.aut", antipalindrome)
#load("automata/antipalindrome.aut", "hoa", antipalindrome(a, i, n))

#load("automata/factor_lt.aut", "hoa", factor_lt(a, i, j, k))
recurrent(a,i,j) := @postprocess[
    bco_valid2(a,i,j) &
    forall s. @postprocess[
        if bco_valid3(a,s,i,j) then
            exists t. @postprocess[
                bco_valid(a,t) & bco_lt(s,t) & factor_lt(a,i,j,t)
            ]
    ]
]
#save_aut("automata/recurrent.aut", recurrent)
#load("automata/recurrent.aut", "hoa", recurrent(a,i,j))

// #load("automata/factor_lt.aut", "hoa", factor_lt(a, i, j, k))
// #load("automata/factor_lt_len.aut", "hoa", factor_lt_len(a, i, n, j))
// uniform_recurrent(a,i,n) := @postprocess[
//     exists l.
//     forall j.
//     exists jl.
//         bco_adder_valid(a,j,l,jl) &
//         exists s.
//             bco_leq(j, s) &
//             exists sn. @postprocess[
//                 bco_adder_valid(a,s,n,sn) & bco_leq(sn,jl)
//             ] &
//             if j > 0 then
//                 factor_lt_len(a,i,n,s)
// ]
// #save_aut("automata/uniform_recurrent.aut", uniform_recurrent)

#load("automata/factor_lt.aut", "hoa", factor_lt(a, i, j, k))
period(a, p, i, j) := @postprocess[
    p > 0 &
    exists ip, jp. @postprocess[
        @postprocess[
            bco_adder_valid(a,i,p,ip) & bco_adder_valid(a,jp,p,j)
        ] &
        factor_lt(a,i,jp,ip)
    ]
]
#save_aut("automata/period.aut", period)
#load("automata/period.aut", "hoa", period(a, p, i, j))

least_period(a, p, i, j) := @postprocess[
    p = min { n : period(a,n,i,j) }
]
#save_aut("automata/least_period.aut", least_period)
#load("automata/least_period.aut", "hoa", least_period(a,p,i,j))

least_period_occurs(a,p) := @postprocess[exists i,j. i > 0 & j > 0 & least_period(a,p,i,j)]
#save_aut("automata/least_period_occurs.aut", least_period_occurs)
#load("automata/least_period_occurs.aut", "hoa", least_period(a,p))

#load("automata/palindrome.aut", "hoa", palindrome(a, i, n))
#load("automata/factor_lt_len.aut", "hoa", factor_lt_len(a, i, n, j))
first_palindrome(a, i, n) := @postprocess[
    palindrome(a, i, n) &
    forall t. @postprocess[
        if bco_positive(t) & @no_simplify[factor_lt_len(a, t, n, i)] then
            bco_leq(i, t)
    ]
]
#save_aut("automata/first_palindrome.aut", first_palindrome)
#load("automata/first_palindrome.aut", "hoa", first_palindrome(a, i, n))

#load("automata/factor_lt_len.aut", "hoa", factor_lt_len(a, i, n, j))
factor_len(a,i,n,j) :=
    factor_lt_len(a,i,n,j) | factor_lt_len(a,j,n,i)
#save_aut("automata/factor_len.aut", factor_len)
#load("automata/factor_len.aut", "hoa", factor_len(a, i, n, j))

Restrict a is bco_standard.
Restrict i,j,k,n are ostrowski(a).
special_factor(a,i,n) := @postprocess[
    (exists j. @no_simplify[factor_lt_len(a,i,n,j)] & $C[j+n] = 0) &
    (exists k. @no_simplify[factor_lt_len(a,i,n,k)] & $C[k+n] = 1)
]
#save_aut("automata/special_factor.aut", special_factor)
#load("automata/special_factor.aut", "hoa", special_factor(a,i,n))
#load("automata/factor_lt_len.aut", "hoa", factor_lt_len(a, i, n, j))
first_special_factor(a,i,n) := @postprocess[@postprocess[@postprocess[
    i > 0 &
    @no_simplify[special_factor(a,i,n)] &
    forall j. if j > 0 & @no_simplify[factor_lt_len(a,j,n,i)] then i <= j
]]]
#save_aut("automata/first_special_factor.aut", first_special_factor)
#load("automata/first_special_factor.aut", "hoa", first_special_factor(a,i,n))

#load("automata/factor_lt_len.aut", "hoa", factor_lt_len(a, i, n, j))
// True when C[i..j] has a border of len n (i.e., C[i..i+n] = C[j-n..j])
border(a,i,j,n) := @postprocess[
    exists jn. @postprocess[
        @postprocess[
            exists ni. @postprocess[
                bco_adder_valid(a,i,n,ni) & bco_leq(ni,jn)
            ]
        ] & bco_adder_valid(a,jn,n,j) & factor_lt_len(a,i,n,jn)
    ]
]
#save_aut("automata/border.aut", border)
#load("automata/border.aut", "hoa", border(a,i,j,n))

unbordered_by_border(a,i,j) := @postprocess[
    forall t. @postprocess[
        if bco_valid(a,t) & bco_positive(t) then !border(a,i,j,t)
    ]
]
#save_aut("automata/unbordered_by_border.aut", unbordered_by_border)
#load("automata/unbordered_by_border.aut", "hoa", unbordered_by_border(a,i,j))

#load("automata/least_period.aut", "hoa", least_period(a,p,i,j))
#load("automata/period.aut", "hoa", period(a, p, i, j))
unbordered(a,i,j) := exists p. least_period(a,p,i,j) & j - i = p
#save_aut("automata/unbordered.aut", unbordered)
#load("automata/unbordered.aut", "hoa", unbordered(a,i,j))

unbordered_len(a,i,n) := @postprocess[ unbordered(a,i,i+n) ]
#save_aut("automata/unbordered_len.aut", unbordered_len)
#load("automata/unbordered_len.aut", "hoa", unbordered_len(a,i,n))

// True when C[i..j] has an unbordered factor at C[k..l]
unbordered_subfactor(a,i,j,k,l) := @postprocess[
    i <= k & l <= j & unbordered(a,k,l)
]
// True when C[i..j] has an unbordered factor of length n
unbordered_subfactor_len(a,i,j,n) := @postprocess[
    exists k. unbordered_subfactor(a,i,j,k,k+n)
]
#save_aut("automata/unbordered_subfactor_len.aut", unbordered_subfactor_len)
#load("automata/unbordered_subfactor_len.aut", "hoa", unbordered_subfactor_len(a,i,j,n))

Restrict m is ostrowski(a).
max_unbordered_subfactor_len(a,i,j,n) := @postprocess[@no_simplify[
    n = max { m : @postprocess[unbordered_subfactor_len(a,i,j,m)] }
]]
#save_aut("automata/max_unbordered_subfactor_len.aut", max_unbordered_subfactor_len)
#load("automata/max_unbordered_subfactor_len.aut", "hoa", max_unbordered_subfactor_len(a,i,j,n))

#load("automata/factor_lt_len.aut", "hoa", factor_lt_len(a, i, n, j))
first_factor_len(a,i,n) := @postprocess[
    bco_valid2(a,i,n) &
    @no_simplify[
    forall t.
        if bco_positive(t) & @no_simplify[factor_lt_len(a, t, n, i)] then
            bco_leq(i, t)
    ]
]
#save_aut("automata/first_factor_len.aut", first_factor_len)
#load("automata/first_factor_len.aut", "hoa", first_factor_len(a,i,n))

#load("automata/unbordered_len.aut", "hoa", unbordered_len(a,i,n))
first_unbordered_len(a,i,n) := @postprocess[
    unbordered_len(a,i,n) & first_factor_len(a,i,n)
]
#save_aut("automata/first_unbordered_len.aut", first_unbordered_len)
#load("automata/first_unbordered_len.aut", "hoa", first_unbordered_len(a,i,n))


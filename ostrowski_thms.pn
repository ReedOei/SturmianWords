#import("ostrowski_defs.pn")

#load("ostrowski-automata/sturmian_word.txt", "pecan", $C(n))

#load("automata/eventually_periodic.aut", "hoa", eventually_periodic(a, p))
#load("automata/pow_2.aut", "hoa", pow_2(a, i, n))
#load("automata/pow_3.aut", "hoa", pow_3(a, i, n))
#load("automata/pow_4.aut", "hoa", pow_4(a, i, n))
#load("automata/pow_5.aut", "hoa", pow_5(a, i, n))
#load("automata/pow_6.aut", "hoa", pow_6(a, i, n))
#load("automata/pow_7.aut", "hoa", pow_7(a, i, n))
#load("automata/pow_8.aut", "hoa", pow_8(a, i, n))
#load("automata/antisquare.aut", "hoa", antisquare(a, i, n))
#load("automata/antipalindrome.aut", "hoa", antipalindrome(a, i, n))

// #load("automata/mirror_invariant.aut", "hoa", mirror_invariant(a, i, j))

#load("automata/fib_alpha.txt", "walnut", fib_alpha(a))
#load("automata/eventually_one.txt", "pecan", eventually_one(a))

Restrict a is bco_standard.
Restrict i, j, k, l, p, n, m are ostrowski(a).

Alias "OstEx" ==> Example (\t => (ostrowskiFormat, t)) .

// Theorem ("Sturmian words are not eventually periodic", {
//     forall a, p. !eventually_periodic(a, p)
// }) .

// Theorem ("All suffixes of Sturmian words start with arbitrarily long squares", {
//     @no_simplify[
//         forall a, j.
//         if j > 0 then
//             forall n. exists m. m > n & pow_2(a, j, m)
//     ]
// }) .

// Theorem ("All Sturmian words contain squares", {
//     @no_simplify[
//         forall a. exists i, n. bco_positive(n) & pow_2(a,i,n)
//     ]
// }) .

// Theorem ("All Sturmian words contain finitely many antisquares", {
//     forall a.
//     exists m.
//     forall i, n. if antisquare(a, i, n) then n <= m
// }).

// Theorem ("All Sturmian words contain cubes", {
//     @no_simplify[
//         forall a. exists i, n. n > 0 & pow_3(a,i,n)
//     ]
// }) .

// Theorem ("All suffixes of Sturmian words start with arbitrarily long cubes.", {
//     @no_simplify[
//         forall a. (!eventually_one(a)) <=>
//         forall j.
//         if j > 0 then
//             forall n.
//             exists m. m > n & pow_3(a, j, m)
//     ]
// }) .

Define genHasNthPow num :=
    let $NTH_POW := "pow_" ^ (toString num) in
    let $HAS_NTH := "has_" ^ $NTH_POW in
        emit { $HAS_NTH(a) := exists i, n. n > 0 & $NTH_POW(a, i, n) } .
Execute genHasNthPow 4.
// Execute genHasNthPow 5.
// Execute genHasNthPow 6.
// Execute genHasNthPow 7.
// Execute genHasNthPow 8.

// Theorem ("All Sturmian words that are not eventually one contain fourth powers", {
//     @no_simplify[
//         forall a. if !eventually_one(a) then has_pow_4(a)
//     ]
// }) .

#load("automata/palindrome.aut", "hoa", palindrome(a, i, j))
#load("automata/palindrome_len.aut", "hoa", palindrome_len(a, i, n))

#load("automata/factor_lt.aut", "hoa", factor_lt(a, i, j, k))
#load("automata/factor_lt_len.aut", "hoa", factor_lt_len(a, i, n, j))
#load("automata/not_same_factor_len.aut", "hoa", not_same_factor_len(a, i, n, j))

// first_palindrome(a, i, j) := @no_simplify[
//     palindrome(a, i, j) &
//         !(
//             exists t, ji.
//                 not_same_factor_len(a, i, ji, t) &
//                 @postprocess[bco_adder(a, ji, i, j) & palindrome_len(a, t, ji)]
//         )
// ]
// #save_aut("first_palindrome.aut", first_palindrome)

// palin_eq(a, i, j, k, l) :=
//     @no_simplify[exists ji.
//         palindrome(a, i, j) &
//         @merge_states[
//             @merge_states[
//                 @postprocess[
//                     bco_adder_valid(a, ji, i, j) &
//                     palindrome_len(a, k, ji)
//                 ] &
//                 palindrome_len(a, l, ji)
//             ] & not_same_factor(a, i, ji, k)
//         ]
//         & not_same_factor(a, i, ji, l)
//     ]
// #save_aut("palin_eq.aut", palin_eq)

// #load("palin_eq.aut", "hoa", palin_eq(a, i, j, k))

// Theorem ("All suffixes of Sturmian words start with arbitarily long palindromes", {
//     forall a, j.
//     if j > 0 then
//         forall n.
//         exists m. m > n & palindrome_len(a, j, m)
// }) .

// Theorem ("Sturmian words contain palindromes of every length.", {
//     forall a, n. if n > 0 then exists i. palindrome_len(a, i, n)
// }).

// #load("automata/has_multipalindromes.aut", "hoa", has_multipalindromes(a, n))
// Theorem ("If n is even there is only 1 palindrome factor of length n", { @no_simplify[
//     forall a,n.
//         if @postprocess[ostrowski_even(a, n)] then !has_multipalindromes(a,n)
// ]}).

// Theorem ("All Sturmian words contain finitely many antipalindromes.", {
//     @no_simplify[
//         forall a.
//         exists m.
//         forall i, n. if antipalindrome(a, i, n) then n <= m
//     ]
// }).

// TODO: Doesn't quite work
// I want to say that a is the smallest slope (i.e., with the lowest cf coefficients) such that it has a palindrome of length n (if it exists at all)
// Actually, that's probably not even well-defined.
// #load("ostrowski-automata/cf_shorter_len.txt", "pecan", cf_shorter_len(a, b))
// has_antipalindrome_len(c, len) := exists idx is ostrowski(c). bco_positive(idx) & antipalindrome(c, idx, len)
// bco_comparable(a, b) := bco_leq(a, b) | bco_leq(b, a)
// Define listSmallestCfWithAntipalindrome curNum :=
//     let $PRED := "smallest_antipalindrome_cf_" ^ (toString curNum) in do
//         print ("Trying: " ^ (toString curNum));
//         emit {
//             $PRED(a) :=
//                 (exists j. j = curNum & has_antipalindrome_len(a, j)) &
//                 (forall b is bco_standard.
//                     if exists len is ostrowski(b). len = curNum & has_antipalindrome_len(b, len) then
//                         (bco_leq(a, b) | cf_shorter_len(a, b))
//                 )
//         };
//         print (example ostrowskiFormat { bco_standard(a) & $PRED(a) });
//         listSmallestCfWithAntipalindrome (curNum + 2). // Note that it is impossible to have an antipalindrome of odd length.
// Execute listSmallestCfWithAntipalindrome 2 .

Define listExamplesIdx $PRED curNum := do
    print ("Trying (pred is " ^ $PRED ^ "): " ^ (toString curNum));
    print (example ostrowskiFormat { bco_standard(a) & n = curNum & $PRED(a, i, n) });
    listExamplesIdx $PRED (curNum + 2) .
// Execute listExamplesIdx antipalindrome 2 .

// Define listAntisquares curNum $PREV_NUM :=
//     let $NEXT_NUM := "bco_" ^ (toString curNum)
//     in do
//         print ("Trying: " ^ (toString curNum));
//         emit { $NEXT_NUM(a, x) := exists y. $PREV_NUM(a, y) & bco_succ(a, y, x) };
//         print (example ostrowskiFormat { bco_standard(a) & bounded_alpha(a) & $NEXT_NUM(a, n) & @no_simplify[antisquare(a, i, n)] });
//         listAntisquares (curNum + 1) $NEXT_NUM .
// #load("test_alpha.txt", "walnut", bounded_alpha(a))
// Execute listAntisquares 2 bco_one .

// Define listExamples $PRED curNum := do
//     print ("Trying (pred is " ^ $PRED ^ "): " ^ (toString curNum));
//     print (example ostrowskiFormat { bco_standard(a) & n = curNum & $PRED(a, n) });
//     listExamples $PRED (curNum + 1) .
// Execute listExamples antisquare_bound 2 .

// Build an automaton recognizing sequences that start with at most `limit` non-zero entries
Define genDigitLimit limit :=
    let aut := mkAut ["num"] [3] in
    let mkName := (\n => "digit_" ^ (toString n)) in
    let autStates := withStates aut (
                        [("start", true), (mkName (limit + 1), true)] @
                        (map (\n => (mkName n, true)) [1..limit])
                    ) in
    let finalAut := withTransitions autStates (
                        [("start", "digit_1", "2"),
                         (mkName (limit + 1), mkName (limit + 1), "0"),
                         (mkName (limit + 1), mkName (limit + 1), "2")] @
                        (flatMap (\n => [(mkName n, mkName n, "0"),
                                         (mkName n, mkName n, "1"),
                                         (mkName n, mkName (n + 1), "2")]) [1..limit])
                    ) in
    let built := buildAut finalAut in
    let $NAME := "is_" ^ (toString limit) ^ "_digits" in do
        emit { $NAME(num) := built } .

Execute genDigitLimit 1.
Execute genDigitLimit 2.
Execute genDigitLimit 3.
Execute genDigitLimit 4.
Execute genDigitLimit 5.
Execute genDigitLimit 6.

antisquare_len(a, i, n) := exists m. 2*m = n & antisquare(a, i, m)

has_antisquare(a, n) := exists i. antisquare(a, i, n)
has_antisquare_len(a, n) := exists i. antisquare_len(a, i, n)
has_antipalindrome(a, n) := exists i. antipalindrome(a, i, n)

max_antisquare(a, n) := has_antisquare(a, n) & forall m. if has_antisquare(a, m) then m <= n
max_antisquare_len(a, n) := has_antisquare_len(a, n) & forall m. if has_antisquare_len(a, m) then m <= n
max_antipalindrome(a, n) := has_antipalindrome(a, n) & forall m. if has_antipalindrome(a, m) then m <= n

not_all_zero(a, i, n) := @postprocess[
    exists j. j < n & $C[i + j] = 1
]

not_all_one(a, i, n) := @postprocess[
    exists j. j < n & $C[i + j] = 0
]

not_all_same(a, i, n) := @postprocess[
    not_all_one(a, i, n) | not_all_zero(a, i, n)
]

// first_palindrome(a, i, n) :=
//     palindrome(a, i, n) & !(exists j. palindrome(a, j, n) & factor_lt_len(a, j, n, i))
// #save_aut("first_palindrome.aut", first_palindrome)

// square2(a, i, n) := @no_simplify[factor_lt(a, i, i + n, i + n)]
// Theorem ("Sanity check that factor_lt let's us redefine something equivalent to square.", { @no_simplify[
//     forall a, i, n.
//         if i > 0 & n > 0 then
//             square2(a, i, n) <=> pow_2(a, i, n)
// ]}).

// Theorem ("max_antisquare is a function.", {
//     (forall a. exists n. max_antisquare(a, n))
//     &
//     (
//         forall a, n, m.
//             if max_antisquare(a, n) & max_antisquare(a, m) then
//                 n = m
//     )
// }).

// Theorem ("max_antisquare_len is a function.", {
//     (forall a. exists n. max_antisquare_len(a, n))
//     &
//     (
//         forall a, n, m.
//             if max_antisquare_len(a, n) & max_antisquare_len(a, m) then
//                 n = m
//     )
// }).

// Theorem ("max_antipalindrome is a function.", {
//     (forall a. exists n. max_antipalindrome(a, n))
//     &
//     (
//         forall a, n, m.
//             if max_antipalindrome(a, n) & max_antipalindrome(a, m) then
//                 n = m
//     )
// }).

// Theorem ("The max_antisquare is half the max_antisquare_len.", {
//     forall a.
//         max_antisquare_len(a) = 2*max_antisquare(a)
// }).

// Theorem ("Each of max_antisquare, max_antisquare_len, and max_antipalindrome is nonzero.", {
//     forall a.
//         max_antisquare(a) >= 1 &
//         max_antisquare_len(a) >= 2 &
//         max_antipalindrome(a) >= 2
// }).

// Theorem ("Maximum order of antisquares and maximum length of palindromes is 4 digits long, and maximum length of antisquares is 6 digits long.", {
//     forall a.
//         is_4_digits(max_antisquare(a)) &
//         is_4_digits(max_antipalindrome(a)) &
//         is_6_digits(max_antisquare_len(a))
// }).

// Theorem ("The maximum length of palindromes in a Sturmian word is bounded by the maximum order of its antisquares and the maximum length of its antisquare.", {
//     (
//         forall a.
//             max_antisquare(a) <= max_antipalindrome(a) &
//             max_antipalindrome(a) <= max_antisquare_len(a)
//     )
//     &
//     (exists a. max_antisquare(a) = max_antipalindrome(a))
//     &
//     (exists a. max_antisquare_len(a) = max_antipalindrome(a))
// }).

// OstEx  { bco_standard(a) & max_antisquare(a, n) & max_antipalindrome(a, n) } .
// OstEx  { bco_standard(a) & max_antisquare_len(a, n) & max_antipalindrome(a, n) } .


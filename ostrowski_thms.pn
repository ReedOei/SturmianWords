#import("ostrowski_defs.pn")

#load("ostrowski-automata/sturmian_word.txt", "pecan", $C(n))

#load("automata/eventually_periodic.aut", "hoa", eventually_periodic(a, p))
#load("automata/pow_2.aut", "hoa", pow_2(a, i, n))
#load("automata/pow_3.aut", "hoa", pow_3(a, i, n))
#load("automata/pow_4.aut", "hoa", pow_4(a, i, n))
#load("automata/pow_5.aut", "hoa", pow_5(a, i, n))
#load("automata/pow_6.aut", "hoa", pow_6(a, i, n))
#load("automata/pow_7.aut", "hoa", pow_7(a, i, n))
#load("automata/pow_8.aut", "hoa", pow_8(a, i, n))
#load("automata/antisquare.aut", "hoa", antisquare(a, i, n))
#load("automata/antipalindrome.aut", "hoa", antipalindrome(a, i, n))
#load("automata/palindrome_prefix.aut", "hoa", palindrome_prefix(a, n))
#load("automata/palindrome.aut", "hoa", palindrome(a, i, n))

// #load("automata/mirror_invariant.aut", "hoa", mirror_invariant(a, i, j))

#load("automata/fib_alpha.txt", "walnut", fib_alpha(a))
#load("automata/eventually_one.txt", "pecan", eventually_one(a))

Restrict a is bco_standard.
Restrict i, j, p, n, m are ostrowski(a).

// Theorem ("Sturmian words are not eventually periodic", {
//     forall a, p. !eventually_periodic(a, p)
// }) .

// Theorem ("All suffixes of Sturmian words start with arbitrarily long squares", {
//     @no_simplify[
//         forall a, j.
//         if j > 0 then
//             forall n. exists m. m > n & pow_2(a, j, m)
//     ]
// }) .

// Theorem ("All Sturmian words contain squares", {
//     @no_simplify[
//         forall a. exists i, n. bco_positive(n) & pow_2(a,i,n)
//     ]
// }) .

// Theorem ("All Sturmian words contain finitely many antisquares", {
//     forall a.
//     exists m.
//     forall i, n. if antisquare(a, i, n) then n <= m
// }).

// Theorem ("All Sturmian words contain cubes", {
//     @no_simplify[
//         forall a. exists i, n. n > 0 & pow_3(a,i,n)
//     ]
// }) .

// Theorem ("All suffixes of Sturmian words start with arbitrarily long cubes.", {
//     @no_simplify[
//         forall a. (!eventually_one(a)) <=>
//         forall j.
//         if j > 0 then
//             forall n.
//             exists m. m > n & pow_3(a, j, m)
//     ]
// }) .

// Define genHasNthPow num :=
//     let $NTH_POW := "pow_" ^ (toString num) in
//     let $HAS_NTH := "has_" ^ $NTH_POW in
//         emit { $HAS_NTH(a) := exists i, n. n > 0 & $NTH_POW(a, i, n) } .
// Execute genHasNthPow 4.
// Execute genHasNthPow 5.
// Execute genHasNthPow 6.
// Execute genHasNthPow 7.
// Execute genHasNthPow 8.

// Theorem ("All Sturmian words that are not eventually one contain fourth powers", {
//     @no_simplify[
//         forall a. if !eventually_one(a) then has_pow_4(a)
//     ]
// }) .

// Theorem ("All suffixes of Sturmian words start with arbitarily long palindromes", {
//     forall a, j.
//     if j > 0 then
//         forall n.
//         exists m. m > n & palindrome(a, j, m)
// }) .

// Theorem ("Sturmian words contain palindromes of every length.", {
//     forall a, n. if n > 0 then exists i. palindrome(a, i, n)
// }).

// Theorem ("All Sturmian words contain finitely many antipalindromes.", {
//     @no_simplify[
//         forall a.
//         exists m.
//         forall i, n. if antipalindrome(a, i, n) then n <= m
//     ]
// }).

// TODO: Doesn't quite work
// I want to say that a is the smallest slope (i.e., with the lowest cf coefficients) such that it has a palindrome of length n (if it exists at all)
// Actually, that's probably not even well-defined.
// #load("ostrowski-automata/cf_shorter_len.txt", "pecan", cf_shorter_len(a, b))
// has_antipalindrome_len(c, len) := exists idx is ostrowski(c). bco_positive(idx) & antipalindrome(c, idx, len)
// bco_comparable(a, b) := bco_leq(a, b) | bco_leq(b, a)
// Define listSmallestCfWithAntipalindrome curNum :=
//     let $PRED := "smallest_antipalindrome_cf_" ^ (toString curNum) in do
//         print ("Trying: " ^ (toString curNum));
//         emit {
//             $PRED(a) :=
//                 (exists j. j = curNum & has_antipalindrome_len(a, j)) &
//                 (forall b is bco_standard.
//                     if exists len is ostrowski(b). len = curNum & has_antipalindrome_len(b, len) then
//                         (bco_leq(a, b) | cf_shorter_len(a, b))
//                 )
//         };
//         print (example ostrowskiFormat { bco_standard(a) & $PRED(a) });
//         listSmallestCfWithAntipalindrome (curNum + 2). // Note that it is impossible to have an antipalindrome of odd length.
// Execute listSmallestCfWithAntipalindrome 2 .

antipalindrome_square(a, i, n) := pow_2(a, i, n) & antipalindrome(a, i, n)
Define listExamples $PRED curNum := do
    print ("Trying (pred is " ^ $PRED ^ "): " ^ (toString curNum));
    print (example ostrowskiFormat { bco_standard(a) & n = curNum & $PRED(a, i, n) });
    listExamples $PRED (curNum + 2) . // Note that it is impossible to have an antipalindrome of odd length.
Execute listExamples antipalindrome_square 2 .
// Execute listExamples antipalindrome 2 .

// Define listAntisquares curNum $PREV_NUM :=
//     let $NEXT_NUM := "bco_" ^ (toString curNum)
//     in do
//         print ("Trying: " ^ (toString curNum));
//         emit { $NEXT_NUM(a, x) := exists y. $PREV_NUM(a, y) & bco_succ(a, y, x) };
//         print (example ostrowskiFormat { bco_standard(a) & bounded_alpha(a) & $NEXT_NUM(a, n) & @no_simplify[antisquare(a, i, n)] });
//         listAntisquares (curNum + 1) $NEXT_NUM .
// #load("test_alpha.txt", "walnut", bounded_alpha(a))
// Execute listAntisquares 2 bco_one .


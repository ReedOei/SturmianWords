#import("ostrowski_defs.pn")
#load("ostrowski-automata/sturmian_word.txt", "pecan", $C(n))

Restrict a is bco_standard.
Restrict i, j, k, l, p, n, m are ostrowski(a).

#load("automata/factor_lt_len.aut", "hoa", factor_lt_len(a, i, n, j))

#load("automata/eventually_periodic.aut", "hoa", eventually_periodic(a, p))
Theorem ("Sturmian words are not eventually periodic", {
    forall a, p. !eventually_periodic(a, p)
}) .

#load("automata/pow_2.aut", "hoa", pow_2(a, i, n))
// square2(a, i, n) := @no_simplify[factor_lt(a, i, i + n, i + n)]
// Theorem ("Sanity check that factor_lt let's us redefine something equivalent to square.", { @no_simplify[
//     forall a, i, n.
//         if i > 0 & n > 0 then
//             square2(a, i, n) <=> pow_2(a, i, n)
// ]}).

#load("ostrowski-automata/cf_pow2.txt", "walnut", cf_pow2(a))

squares_in_pow2(a, n) := @postprocess[
    bco_standard(a) & cf_pow2(a) & exists i. pow_2(a,i,n)
]
#save_aut_img("squares_in_pow2.svg", squares_in_pow2)

Theorem ("All Sturmian words start with arbitrarily long squares", {
    @no_simplify[
        forall a.
        forall n. exists m, j. j = 1 & m > n & pow_2(a, j, m)
    ]
}) .

Theorem ("All Sturmian words contain squares", {
    @no_simplify[
        forall a. exists i, n. bco_positive(n) & pow_2(a,i,n)
    ]
}) .

#load("ostrowski-automata/semiconvergent.txt", "pecan", semiconvergent(n))
Theorem ("If n is the order of a square, then n is the denominator of some semiconvergent of a.", {
    forall a,i,n.
        if i > 0 & n > 0 & pow_2(a,i,n) then
            n is semiconvergent
}).

#load("automata/antisquare.aut", "hoa", antisquare(a, i, n))
Theorem ("All Sturmian words contain finitely many antisquares", {
    forall a.
    exists m.
    forall i, n. if antisquare(a, i, n) then n <= m
}).

#load("automata/pow_3.aut", "hoa", pow_3(a, i, n))
Theorem ("All Sturmian words contain cubes", {
    @no_simplify[
        forall a. exists i, n. n > 0 & pow_3(a,i,n)
    ]
}) .

#load("ostrowski-automata/eventually_one.txt", "pecan", eventually_one(a))
Theorem ("All suffixes of Sturmian words start with arbitrarily long cubes.", {
    @no_simplify[
        forall a. (!eventually_one(a)) <=>
        forall j.
        if j > 0 then
            forall n.
            exists m. m > n & pow_3(a, j, m)
    ]
}) .

#load("automata/pow_4.aut", "hoa", pow_4(a, i, n))
Define genHasNthPow num :=
    let $NTH_POW := "pow_" ^ (toString num) in
    let $HAS_NTH := "has_" ^ $NTH_POW in
        emit { $HAS_NTH(a) := exists i, n. n > 0 & $NTH_POW(a, i, n) } .

Execute genHasNthPow 4.
Theorem ("All Sturmian words that are not eventually one contain fourth powers", {
    @no_simplify[
        forall a. if !eventually_one(a) then has_pow_4(a)
    ]
}) .

#load("automata/palindrome.aut", "hoa", palindrome(a, i, n))
#load("automata/factor_len.aut", "hoa", factor_len(a,i,n,j))

Theorem ("Sturmian words are balanced.", {
    forall a. !(exists i,n. palindrome(a, i, n) &
                (exists j. factor_len(a,i,n,j) & $C[j - 1] = 0 & $C[j + n] = 0) &
                (exists k. factor_len(a,i,n,k) & $C[k - 1] = 1 & $C[k + n] = 1))
}).

// palindromes_in_pow2(a,n) := @postprocess[
//     bco_standard(a) & cf_pow2(a) & exists i. palindrome(a,i,n)
// ]
// #save_aut_img("palindromes_in_pow2.svg", palindromes_in_pow2)

Theorem ("Sturmian words contain palindromes of every length.", {
    forall a, n. if n > 0 then exists i. palindrome(a, i, n)
}).

#load("automata/first_palindrome.aut", "hoa", first_palindrome(a, i, n))
Theorem ("For all Sturmian words, if n is even then it contains exactly one palindrome of length n, and if n is odd then it contains exactly two palindromes of length n.", {
    forall a,n. (
        if n is even & n > 0 then
            exists i. forall k. first_palindrome(a, k, n) iff i = k
    ) & (
        if @no_simplify[n is odd] then
            exists i,j. i < j & forall k. first_palindrome(a,k,n) iff (i = k | j = k)
    )
}).

Theorem ("Sturmian words start with arbitarily long palindromes", {
    forall a,n.
    exists m. m > n & exists j. j = 1 & palindrome(a, j, m)
}) .

#load("automata/antipalindrome.aut", "hoa", antipalindrome(a, i, n))
Theorem ("All Sturmian words contain finitely many antipalindromes.", {
    @no_simplify[
        forall a.
        exists m.
        forall i, n. if antipalindrome(a, i, n) then n <= m
    ]
}).

// TODO: Doesn't quite work
// I want to say that a is the smallest slope (i.e., with the lowest cf coefficients) such that it has a palindrome of length n (if it exists at all)
// Actually, that's probably not even well-defined.
// #load("ostrowski-automata/cf_shorter_len.txt", "pecan", cf_shorter_len(a, b))
// has_antipalindrome(c, len) := exists idx is ostrowski(c). bco_positive(idx) & antipalindrome(c, idx, len)
// bco_comparable(a, b) := bco_leq(a, b) | bco_leq(b, a)
// Define listSmallestCfWithAntipalindrome curNum :=
//     let $PRED := "smallest_antipalindrome_cf_" ^ (toString curNum) in do
//         print ("Trying: " ^ (toString curNum));
//         emit {
//             $PRED(a) :=
//                 (exists j. j = curNum & has_antipalindrome(a, j)) &
//                 (forall b is bco_standard.
//                     if exists len is ostrowski(b). len = curNum & has_antipalindrome(b, len) then
//                         (bco_leq(a, b) | cf_shorter_len(a, b))
//                 )
//         };
//         print (example ostrowskiFormat { bco_standard(a) & $PRED(a) });
//         listSmallestCfWithAntipalindrome (curNum + 2). // Note that it is impossible to have an antipalindrome of odd length.
// Execute listSmallestCfWithAntipalindrome 2 .

// Define listExamplesIdx $PRED curNum := do
//     print ("Trying (pred is " ^ $PRED ^ "): " ^ (toString curNum));
//     print (example ostrowskiFormat { bco_standard(a) & n = curNum & $PRED(a, i, n) });
//     listExamplesIdx $PRED (curNum + 2) .
// Execute listExamplesIdx antipalindrome 2 .

// Define listAntisquares curNum $PREV_NUM :=
//     let $NEXT_NUM := "bco_" ^ (toString curNum)
//     in do
//         print ("Trying: " ^ (toString curNum));
//         emit { $NEXT_NUM(a, x) := exists y. $PREV_NUM(a, y) & bco_succ(a, y, x) };
//         print (example ostrowskiFormat { bco_standard(a) & bounded_alpha(a) & $NEXT_NUM(a, n) & @no_simplify[antisquare(a, i, n)] });
//         listAntisquares (curNum + 1) $NEXT_NUM .
// #load("test_alpha.txt", "walnut", bounded_alpha(a))
// Execute listAntisquares 2 bco_one .

// Define listExamples $PRED curNum := do
//     print ("Trying (pred is " ^ $PRED ^ "): " ^ (toString curNum));
//     print (example ostrowskiFormat { bco_standard(a) & n = curNum & $PRED(a, n) });
//     listExamples $PRED (curNum + 1) .
// Execute listExamples antisquare_bound 2 .

// Build an automaton recognizing sequences that start with at most `limit` non-zero entries

antisquare_len(a, i, n) := exists m. 2*m = n & antisquare(a, i, m)

has_antisquare(a, n) := exists i. antisquare(a, i, n)
has_antisquare_len(a, n) := exists i. antisquare_len(a, i, n)
has_antipalindrome(a, n) := exists i. antipalindrome(a, i, n)

max_antisquare(a, n) := has_antisquare(a, n) & forall m. if has_antisquare(a, m) then m <= n
max_antisquare_len(a, n) := has_antisquare_len(a, n) & forall m. if has_antisquare_len(a, m) then m <= n
max_antipalindrome(a, n) := has_antipalindrome(a, n) & forall m. if has_antipalindrome(a, m) then m <= n

Define genVars num :=
    if num = 0 then
        []
    else
        let newVar := "v" ^ (toString num) in
        let rest := genVars (num - 1) in do
            emit { Restrict newVar is ostrowski(a). };
            newVar :: rest .

Define test prev vars :=
    match vars with
    case [x] => { exists x. prev < x & has_antisquare(a,x) }
    case x :: xs =>
        let next := test x xs
        in { exists x. prev < x & has_antisquare(a,x) & next }
    end.

Define check prev vars :=
    let pred := test prev vars in
        emit { test(a) := pred }.

Example using ostrowskiFormat of {
    0 < n & j < k & l < p &
    @postprocess[antisquare(a,i,n) & 0 < i & i < j & antisquare(a,j,n)] &
    @postprocess[antisquare(a,k,n) & k < l & antisquare(a,l,n)] &
    @postprocess[antisquare(a,p,n) & p < m & antisquare(a,m,n)]
}.
Theorem ("max_antisquare is a function_1", {
    forall a. exists n. max_antisquare(a, n)
}).

Theorem ("max_antisquare is a function_2", {
    forall a, n, m.
        if max_antisquare(a, n) & max_antisquare(a, m) then
            n = m
}).

Theorem ("max_antisquare_len is a function_1", {
    (forall a. exists n. max_antisquare_len(a, n))
}).

Theorem ("max_antisquare_len is a function_2", {
    forall a, n, m.
        if max_antisquare_len(a, n) & max_antisquare_len(a, m) then
            n = m
}).

Theorem ("max_antipalindrome is a function_1", {
    forall a. exists n. max_antipalindrome(a, n)
}).

Theorem ("max_antipalindrome is a function_2", {
    forall a, n, m.
        if max_antipalindrome(a, n) & max_antipalindrome(a, m) then
            n = m
}).

Theorem ("The max_antisquare is half the max_antisquare_len.", {
    forall a.
        max_antisquare_len(a) = 2*max_antisquare(a)
}).

Theorem ("Each of max_antisquare, max_antisquare_len, and max_antipalindrome is nonzero.", {
    forall a.
        max_antisquare(a) >= 1 &
        max_antisquare_len(a) >= 2 &
        max_antipalindrome(a) >= 2
}).

Theorem ("Maximum order of antisquares and maximum length of antipalindromes is 4 digits long, and maximum length of antisquares is 6 digits long.", {
    forall a.
        is_4_digits(max_antisquare(a)) &
        is_4_digits(max_antipalindrome(a)) &
        is_6_digits(max_antisquare_len(a))
}).

Theorem ("The maximum length of palindromes in a Sturmian word is bounded by the maximum order of its antisquares and the maximum length of its antisquare.", {
    forall a.
        max_antisquare(a) <= max_antipalindrome(a) &
        max_antipalindrome(a) <= max_antisquare_len(a)
}).

Theorem ("Both extremes have witnesses_1", {
    exists a. max_antisquare(a) = max_antipalindrome(a)
}).
Theorem ("Both extremes have witnesses_2", {
    exists a. max_antisquare_len(a) = max_antipalindrome(a)
}).
    >>>>>>> db982a6b7cc5184ed531a5ba85256da4120ded14

    // TODO: Why are so many of these lengths 1010^w?
    // Example using ostrowskiFormat of {
    //     max_antisquare(a,n) & bco_valid(a,n) &
    //     n = max_antipalindrome(a) & n > 100
    //     // n = max_antipalindrome(a) & !is_4_digits(n)
    // }.

    // Theorem ("Test", {
    //     forall a.
    //         max_antisquare(a) = max_antipalindrome(a) <=> max_antisquare(a) = 2
    // }).

    #load("automata/mirror_invariant.aut", "hoa", mirror_invariant(a, i, j))
    Theorem ("Every Sturmian word is mirror invariant.", {
        forall a,i,j.
        if 0 < i & i < j then
            mirror_invariant(a,i,j)
    }).

    #load("automata/reverse_factor.aut", "hoa", reverse_factor(a, i, j, l))
    #load("automata/first_special_factor.aut", "hoa", first_special_factor(a,i,n))
    Theorem ("Specal factors are unique", {
        forall a.
        forall i,j,n. if first_special_factor(a,i,n) & first_special_factor(a,j,n) then i = j
    }).

    // Note: This theorem also proves uniqueness.
    // Another random note: We could define C[i..j] = C[k..l] in terms of reverse factor.
    Theorem ("The unique special factor of length n is C[1..n]^R", { @no_simplify[
        forall a.
        forall i, n. @postprocess[
            if i > 0 & first_special_factor(a,i,n) then
                reverse_factor(a,i,i+n,n)
        ]
    ]}).

    // #load("automata/factor_test.aut", "hoa", factor_test(a,i,n,j))
    // Example using ostrowskiFormat of { @no_simplify[
    //     n > 0 & i > 0 &
    //     bco_valid3(a,i,n,j) & i < j & factor_lt_len(a,i,n,j) & !factor_test(a,i,n,j)
    // ]}.
    // Theorem ("Sanity check for factor_test.", { @no_simplify[
    //     forall a,i,n,j.
    //         if n > 0 & 0 < i & i < j then
    //             factor_lt_len(a,i,n,j) <=> factor_test(a,i,n,j)
    // ] }).

    // #load("automata/least_period.aut", "hoa", least_period(a,p,i,j))
    // #load("automata/least_period_old.aut", "hoa", least_period_old(a,p,i,j))
    // Theorem ("Sanity check: least period definition manually is equivalent to the one we get from Pecan's internal min function.", {
    //     forall a,p,i,j. least_period(a,p,i,j) <=> least_period_old(a,p,i,j)
    // }).

    #load("automata/least_period_occurs.aut", "hoa", least_period_occurs(a,p))
    #load("ostrowski-automata/semiconvergent.txt", "pecan", semiconvergent(n))
    Theorem ("If p is a least period of a factor of C_alpha, then p is the denominator of a semiconvergent of alpha.", {
        forall a,p. if least_period_occurs(a,p) then semiconvergent(p)
    }).

    #load("automata/recurrent.aut", "hoa", recurrent(a,i,j))
    Theorem ("All factors of Sturmian words are recurrent.", {
        forall a,i,j.
            if i < j then recurrent(a,i,j)
    }).

    #load("automata/unbordered_by_border.aut", "hoa", unbordered_by_border(a,i,j))
    #load("automata/unbordered.aut", "hoa", unbordered(a,i,j))
    #load("automata/border.aut", "hoa", border(a,i,j,n))

    Theorem ("Sanity check: Defining unbordered factors in two ways that should be equivalent.", { @no_simplify[
        forall a,i,j.
            if 0 < i & i < j then
                (if exists t. bco_positive(t) & border(a,i,j,t) then !unbordered(a,i,j))
                &
                (if !unbordered(a,i,j) then !unbordered_by_border(a,i,j))
    ] }).

    Theorem ("Every unbordered factor has a length that is the denominator of a semiconvergent.", {
        forall a,i,n.
            if i > 0 & n > 0 & unbordered_len(a,i,n) then
                semiconvergent(n)
    }).

    #load("automata/max_unbordered_subfactor_len.aut", "hoa", max_unbordered_subfactor_len(a,i,j,n))
    #load("automata/least_period.aut", "hoa", least_period(a,p,i,j))
    Theorem ("The least period if C[i..j] is the length of the longest unbordered factor of C[i..j].", {
        forall a,i,j,p.
            if i > 0 & j > i & p > 0 then
                least_period(a,p,i,j) <=> max_unbordered_subfactor_len(a,i,j,p)
    }).

    // Random conjecture: The longest antisquare in any $C_{\alpha}$ where all terms in the continued fraction for $\alpha$ are less than $n$ is $n$, seems to be true for some basic tests, at least using bounds of $2^m - 1$ and finding antisquares up to length $2^m$ for $m = 1,2,3$. Not sure if it's actually possible to prove this using Pecan though.

    #load("automata/first_unbordered_len.aut", "hoa", first_unbordered_len(a,i,n))
    Theorem ("All Sturmian words contain exactly two unbordered factors of each length.", {
        forall a,n.
            exists i,j. i < j &
            forall k. if first_unbordered_len(a,k,n) then k in {i,j}
    }).

    // #load("automata/reverse_factor.aut", "hoa", reverse_factor(a, i, j, l))
    // Example using ostrowskiFormat of { @no_simplify[
    //     first_unbordered_len(a,i,n) & first_unbordered_len(a,j,n) & reverse_factor(a,i,i+n,j+n-1)
    // ] }.

    // See: https://arxiv.org/abs/2005.11718
    #load("ostrowski-automata/as_long_as.txt", "pecan", as_long_as(x,y))
    #load("ostrowski-automata/suffix_after.txt", "pecan", suffix_after(x,y,suf))
    #load("automata/period.aut", "hoa", period(a,p,i,j))
    Restrict s are ostrowski(a).

    p is $Per(a,n) := exists s. s = 1 & period(a,p,s,n+1)

    p is $A(a,n) :=
        exists n_l,m_l. lazy_ostrowski(a,n_l) & ost_equiv(a,n,n_l) &
        exists m. ost_equiv(a,m_l,m) &
        exists i. i > 0 & has_1_digits(i) & as_long_as(n,i) &
            bounded_by(i,n_l) & suffix_after(i,n_l,m_l) &
            i + m = p


    Theorem ("Theorem 6 (b) from 'An inequality for the number of periods in a word'", {
        forall a. forall p,n. p is $Per(a,n) <=> p is $A(a,n)
    }).


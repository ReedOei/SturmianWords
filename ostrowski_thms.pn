#import("ostrowski_defs.pn")

#load("ostrowski-automata/sturmian_word.txt", "pecan", $C(n))

Restrict a is bco_standard.
Restrict i, j, k, l, p, n, m are ostrowski(a).

Alias "OstEx" ==> Example (\t => (ostrowskiFormat, t)) .

// #load("automata/eventually_periodic.aut", "hoa", eventually_periodic(a, p))
// Theorem ("Sturmian words are not eventually periodic", {
//     forall a, p. !eventually_periodic(a, p)
// }) .

// #load("automata/pow_2.aut", "hoa", pow_2(a, i, n))
// square2(a, i, n) := @no_simplify[factor_lt(a, i, i + n, i + n)]
// Theorem ("Sanity check that factor_lt let's us redefine something equivalent to square.", { @no_simplify[
//     forall a, i, n.
//         if i > 0 & n > 0 then
//             square2(a, i, n) <=> pow_2(a, i, n)
// ]}).


// Theorem ("All Sturmian words start with arbitrarily long squares", {
//     @no_simplify[
//         forall a.
//         forall n. exists m, j. j = 1 & m > n & pow_2(a, j, m)
//     ]
// }) .

// Theorem ("All Sturmian words contain squares", {
//     @no_simplify[
//         forall a. exists i, n. bco_positive(n) & pow_2(a,i,n)
//     ]
// }) .

// #load("ostrowski-automata/semiconvergent.txt", "pecan", semiconvergent(n))
// Theorem ("If n is the order of a square, then n is the denominator of some semiconvergent of a.", {
//     forall a,i,n.
//         if i > 0 & n > 0 & pow_2(a,i,n) then
//             n is semiconvergent
// }).

// #load("automata/antisquare.aut", "hoa", antisquare(a, i, n))
// Theorem ("All Sturmian words contain finitely many antisquares", {
//     forall a.
//     exists m.
//     forall i, n. if antisquare(a, i, n) then n <= m
// }).

// #load("automata/pow_3.aut", "hoa", pow_3(a, i, n))
// Theorem ("All Sturmian words contain cubes", {
//     @no_simplify[
//         forall a. exists i, n. n > 0 & pow_3(a,i,n)
//     ]
// }) .

// #load("ostrowski-automata/eventually_one.txt", "pecan", eventually_one(a))
// Theorem ("All suffixes of Sturmian words start with arbitrarily long cubes.", {
//     @no_simplify[
//         forall a. (!eventually_one(a)) <=>
//         forall j.
//         if j > 0 then
//             forall n.
//             exists m. m > n & pow_3(a, j, m)
//     ]
// }) .

Define genHasNthPow num :=
    let $NTH_POW := "pow_" ^ (toString num) in
    let $HAS_NTH := "has_" ^ $NTH_POW in
        emit { $HAS_NTH(a) := exists i, n. n > 0 & $NTH_POW(a, i, n) } .

// Execute genHasNthPow 4.
// #load("automata/pow_4.aut", "hoa", pow_4(a, i, n))
// Theorem ("All Sturmian words that are not eventually one contain fourth powers", {
//     @no_simplify[
//         forall a. if !eventually_one(a) then has_pow_4(a)
//     ]
// }) .

// #load("automata/palindrome.aut", "hoa", palindrome(a, i, n))
// Theorem ("Sturmian words contain palindromes of every length.", {
//     forall a, n. if n > 0 then exists i. palindrome(a, i, n)
// }).

// #load("automata/first_palindrome.aut", "hoa", first_palindrome(a, i, n))
// Theorem ("For all Sturmian words, if n is even then it contains exactly one palindrome of length n, and if n is odd then it contains exactly two palindromes of length n.", {
//     forall a,n. (
//         if n is even & n > 0 then
//             exists i. forall k. first_palindrome(a, k, n) iff i = k
//     ) & (
//         if @no_simplify[n is odd] then
//             exists i,j. i < j & forall k. first_palindrome(a,k,n) iff (i = k | j = k)
//     )
// }).

// Theorem ("Sturmian words start with arbitarily long palindromes", {
//     forall a,n.
//     exists m. m > n & exists j. j = 1 & palindrome(a, j, m)
// }) .

// #load("automata/antipalindrome.aut", "hoa", antipalindrome(a, i, n))
// Theorem ("All Sturmian words contain finitely many antipalindromes.", {
//     @no_simplify[
//         forall a.
//         exists m.
//         forall i, n. if antipalindrome(a, i, n) then n <= m
//     ]
// }).

// TODO: Doesn't quite work
// I want to say that a is the smallest slope (i.e., with the lowest cf coefficients) such that it has a palindrome of length n (if it exists at all)
// Actually, that's probably not even well-defined.
// #load("ostrowski-automata/cf_shorter_len.txt", "pecan", cf_shorter_len(a, b))
// has_antipalindrome(c, len) := exists idx is ostrowski(c). bco_positive(idx) & antipalindrome(c, idx, len)
// bco_comparable(a, b) := bco_leq(a, b) | bco_leq(b, a)
// Define listSmallestCfWithAntipalindrome curNum :=
//     let $PRED := "smallest_antipalindrome_cf_" ^ (toString curNum) in do
//         print ("Trying: " ^ (toString curNum));
//         emit {
//             $PRED(a) :=
//                 (exists j. j = curNum & has_antipalindrome(a, j)) &
//                 (forall b is bco_standard.
//                     if exists len is ostrowski(b). len = curNum & has_antipalindrome(b, len) then
//                         (bco_leq(a, b) | cf_shorter_len(a, b))
//                 )
//         };
//         print (example ostrowskiFormat { bco_standard(a) & $PRED(a) });
//         listSmallestCfWithAntipalindrome (curNum + 2). // Note that it is impossible to have an antipalindrome of odd length.
// Execute listSmallestCfWithAntipalindrome 2 .

// Define listExamplesIdx $PRED curNum := do
//     print ("Trying (pred is " ^ $PRED ^ "): " ^ (toString curNum));
//     print (example ostrowskiFormat { bco_standard(a) & n = curNum & $PRED(a, i, n) });
//     listExamplesIdx $PRED (curNum + 2) .
// Execute listExamplesIdx antipalindrome 2 .

// Define listAntisquares curNum $PREV_NUM :=
//     let $NEXT_NUM := "bco_" ^ (toString curNum)
//     in do
//         print ("Trying: " ^ (toString curNum));
//         emit { $NEXT_NUM(a, x) := exists y. $PREV_NUM(a, y) & bco_succ(a, y, x) };
//         print (example ostrowskiFormat { bco_standard(a) & bounded_alpha(a) & $NEXT_NUM(a, n) & @no_simplify[antisquare(a, i, n)] });
//         listAntisquares (curNum + 1) $NEXT_NUM .
// #load("test_alpha.txt", "walnut", bounded_alpha(a))
// Execute listAntisquares 2 bco_one .

// Define listExamples $PRED curNum := do
//     print ("Trying (pred is " ^ $PRED ^ "): " ^ (toString curNum));
//     print (example ostrowskiFormat { bco_standard(a) & n = curNum & $PRED(a, n) });
//     listExamples $PRED (curNum + 1) .
// Execute listExamples antisquare_bound 2 .

// Build an automaton recognizing sequences that start with at most `limit` non-zero entries
Define genDigitLimit limit :=
    let aut := mkAut ["num"] [3] in
    let mkName := (\n => "digit_" ^ (toString n)) in
    let autStates := withStates aut (
                        [("start", true), (mkName (limit + 1), true)] @
                        (map (\n => (mkName n, true)) [1..limit])
                    ) in
    let finalAut := withTransitions autStates (
                        [("start", "digit_1", "2"),
                         (mkName (limit + 1), mkName (limit + 1), "0"),
                         (mkName (limit + 1), mkName (limit + 1), "2")] @
                        (flatMap (\n => [(mkName n, mkName n, "0"),
                                         (mkName n, mkName n, "1"),
                                         (mkName n, mkName (n + 1), "2")]) [1..limit])
                    ) in
    let built := buildAut finalAut in
    let $NAME := "is_" ^ (toString limit) ^ "_digits" in do
        emit { $NAME(num) := built } .

Execute genDigitLimit 1.
Execute genDigitLimit 2.
Execute genDigitLimit 3.
Execute genDigitLimit 4.
Execute genDigitLimit 5.
Execute genDigitLimit 6.

// antisquare_len(a, i, n) := exists m. 2*m = n & antisquare(a, i, m)

// has_antisquare(a, n) := exists i. antisquare(a, i, n)
// has_antisquare_len(a, n) := exists i. antisquare_len(a, i, n)
// has_antipalindrome(a, n) := exists i. antipalindrome(a, i, n)

// max_antisquare(a, n) := has_antisquare(a, n) & forall m. if has_antisquare(a, m) then m <= n
// max_antisquare_len(a, n) := has_antisquare_len(a, n) & forall m. if has_antisquare_len(a, m) then m <= n
// max_antipalindrome(a, n) := has_antipalindrome(a, n) & forall m. if has_antipalindrome(a, m) then m <= n

// Theorem ("max_antisquare is a function.", {
//     (forall a. exists n. max_antisquare(a, n))
//     &
//     (
//         forall a, n, m.
//             if max_antisquare(a, n) & max_antisquare(a, m) then
//                 n = m
//     )
// }).

// Theorem ("max_antisquare_len is a function.", {
//     (forall a. exists n. max_antisquare_len(a, n))
//     &
//     (
//         forall a, n, m.
//             if max_antisquare_len(a, n) & max_antisquare_len(a, m) then
//                 n = m
//     )
// }).

// Theorem ("max_antipalindrome is a function.", {
//     (forall a. exists n. max_antipalindrome(a, n))
//     &
//     (
//         forall a, n, m.
//             if max_antipalindrome(a, n) & max_antipalindrome(a, m) then
//                 n = m
//     )
// }).

// Theorem ("The max_antisquare is half the max_antisquare_len.", {
//     forall a.
//         max_antisquare_len(a) = 2*max_antisquare(a)
// }).

// Theorem ("Each of max_antisquare, max_antisquare_len, and max_antipalindrome is nonzero.", {
//     forall a.
//         max_antisquare(a) >= 1 &
//         max_antisquare_len(a) >= 2 &
//         max_antipalindrome(a) >= 2
// }).

// Theorem ("Maximum order of antisquares and maximum length of palindromes is 4 digits long, and maximum length of antisquares is 6 digits long.", {
//     forall a.
//         is_4_digits(max_antisquare(a)) &
//         is_4_digits(max_antipalindrome(a)) &
//         is_6_digits(max_antisquare_len(a))
// }).

// Theorem ("The maximum length of palindromes in a Sturmian word is bounded by the maximum order of its antisquares and the maximum length of its antisquare.", {
//     (
//         forall a.
//             max_antisquare(a) <= max_antipalindrome(a) &
//             max_antipalindrome(a) <= max_antisquare_len(a)
//     )
//     &
//     (exists a. max_antisquare(a) = max_antipalindrome(a))
//     &
//     (exists a. max_antisquare_len(a) = max_antipalindrome(a))
// }).

// OstEx  { bco_standard(a) & max_antisquare(a, n) & max_antipalindrome(a, n) } .
// OstEx  { bco_standard(a) & max_antisquare_len(a, n) & max_antipalindrome(a, n) } .

// #load("automata/mirror_invariant.aut", "hoa", mirror_invariant(a, i, j))
// Theorem ("Every Sturmian word is mirror invariant.", {
//     forall a,i,j.
//     if 0 < i & i < j then
//         mirror_invariant(a,i,j)
// }).

// #load("automata/reverse_factor.aut", "hoa", reverse_factor(a, i, j, l))
// #load("automata/first_special_factor.aut", "hoa", first_special_factor(a,i,n))
// Theorem ("Specal factors are unique", {
//     forall a.
//     forall i,j,n. if first_special_factor(a,i,n) & first_special_factor(a,j,n) then i = j
// }).

// Note: This theorem also proves uniqueness.
// Another random note: We could define C[i..j] = C[k..l] in terms of reverse factor.
// Theorem ("The unique special factor of length n is C[1..n]^R", { @no_simplify[
//     forall a.
//     forall i, n. @postprocess[
//         if i > 0 & first_special_factor(a,i,n) then
//             reverse_factor(a,i,i+n,n)
//     ]
// ]}).

// #load("automata/factor_test.aut", "hoa", factor_test(a,i,n,j))
// #load("automata/factor_lt_len.aut", "hoa", factor_lt_len(a, i, n, j))
// Example using ostrowskiFormat of { @no_simplify[
//     n > 0 & i > 0 &
//     bco_valid3(a,i,n,j) & i < j & factor_lt_len(a,i,n,j) & !factor_test(a,i,n,j)
// ]}.
// Theorem ("Sanity check for factor_test.", { @no_simplify[
//     forall a,i,n,j.
//         if n > 0 & 0 < i & i < j then
//             factor_lt_len(a,i,n,j) <=> factor_test(a,i,n,j)
// ] }).

// Build an automaton recognizing sequences that have at most `limit` non-zero entries
Define genHasNDigits limit :=
    let aut := mkAut ["num"] [3] in
    let mkName := (\n => "digit_" ^ (toString n)) in
    let mkNameNonZero := (\n => "digit_nonzero_" ^ (toString n)) in
    let autStates := withStates aut (
                        [("start", true), (mkName (limit + 1), true)] @
                        (map (\n => (mkName n, true)) [1..limit]) @
                        (map (\n => (mkNameNonZero n, true)) [1..limit])
                    ) in
    let finalAut := withTransitions autStates (
                        [("start", "digit_1", "2"),
                         (mkName (limit + 1), mkName (limit + 1), "0"),
                         (mkName (limit + 1), mkName (limit + 1), "2")] @
                        (flatMap (\n => [(mkName n, mkName n, "0"),
                                         (mkName n, mkNameNonZero n, "1"),
                                         (mkName n, mkName n, "2")]) [1..limit]) @
                        (flatMap (\n => [(mkNameNonZero n, mkNameNonZero n, "0"),
                                         (mkNameNonZero n, mkNameNonZero n, "1"),
                                         (mkNameNonZero n, mkName (n+1), "2")]) [1..limit])
                    ) in
    let built := buildAut finalAut in
    let $NAME := "has_" ^ (toString limit) ^ "_digits" in do
        emit { $NAME(num) := built } .

Execute genHasNDigits 1.
// Execute genHasNDigits 2.
// Execute genHasNDigits 3.
// Execute genHasNDigits 4.
// Execute genHasNDigits 5.
// Execute genHasNDigits 6.
// Execute genHasNDigits 7.
// Execute genHasNDigits 15.
// Execute genHasNDigits 40.

// #load("automata/least_period.aut", "hoa", least_period(a,p,i,j))
// #load("automata/least_period_old.aut", "hoa", least_period_old(a,p,i,j))
// Theorem ("Sanity check: least period definition manually is equivalent to the one we get from Pecan's internal min function.", {
//     forall a,p,i,j. least_period(a,p,i,j) <=> least_period_old(a,p,i,j)
// }).

// #load("automata/least_period_occurs.aut", "hoa", least_period_occurs(a,p))
// #load("ostrowski-automata/semiconvergent.txt", "pecan", semiconvergent(n))
// Theorem ("If p is a least period of a factor of C_alpha, then p is the denominator of a semiconvergent of alpha.", {
//     forall a,p. if least_period_occurs(a,p) then semiconvergent(p)
// }).

////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
// TODO: Do stuff with recurrence
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////

// #load("automata/recurrent.aut", "hoa", recurrent(a,i,j))
// Theorem ("All factors of Sturmian words are recurrent.", {
//     forall a,i,j.
//         if i < j then recurrent(a,i,j)
// }).

// #load("automata/unbordered.aut", "hoa", unbordered(a,i,j))
// #load("automata/unbordered_by_period.aut", "hoa", unbordered_by_period(a,i,j))
// #load("automata/border.aut", "hoa", border(a,i,j,n))

// Theorem ("Sanity check: Defining unbordered factors in two ways that should be equivalent.", { @no_simplify[
//     forall a,i,j.
//         if 0 < i & i < j then
//             (if exists t. bco_positive(t) & border(a,i,j,t) then !unbordered_by_period(a,i,j))
//             &
//             (if !unbordered_by_period(a,i,j) then !unbordered(a,i,j))
// ] }).

